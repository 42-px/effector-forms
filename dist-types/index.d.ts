// Generated by dts-bundle-generator v6.7.0

import { Domain, Event, Store } from 'effector';

export declare type InitFieldValue<Value> = () => Value;
export declare type ValidationEvent = "submit" | "blur" | "change";
export declare type ValidationResult = {
	isValid: boolean;
	errorText?: string;
};
export declare type Validator<Value, Form = any, Source = any> = (value: Value, form?: Form, source?: Source) => boolean | ValidationResult;
export declare type ValidationError<Value = any> = {
	rule: string;
	value: Value;
	errorText?: string;
};
export declare type Rule<Value, Form = any, Source = any> = {
	name: string;
	errorText?: string;
	source?: Store<Source>;
	validator: Validator<Value, Form, Source>;
};
export declare type FieldData<Value> = {
	value: Value;
	errors: ValidationError<Value>[];
	firstError: ValidationError<Value> | null;
	isValid: boolean;
	isDirty: boolean;
	isTouched: boolean;
};
export declare type Field<Value> = {
	name: string;
	$value: Store<Value>;
	$errors: Store<ValidationError<Value>[]>;
	$firstError: Store<ValidationError<Value> | null>;
	$isValid: Store<boolean>;
	$isDirty: Store<boolean>;
	$isTouched: Store<boolean>;
	$touched: Store<boolean>;
	$field: Store<FieldData<Value>>;
	onChange: Event<Value>;
	changed: Event<Value>;
	onBlur: Event<void>;
	addError: Event<{
		rule: string;
		errorText?: string;
	}>;
	validate: Event<void>;
	reset: Event<void>;
	set: Event<Value>;
	resetErrors: Event<void>;
	resetValue: Event<void>;
	filter?: Store<boolean> | FilterFunc<Value>;
};
export declare type FilterFunc<Value> = (value: Value) => boolean;
export declare type RuleResolver<Value = any, Form = any> = (value: Value, form: Form) => Rule<Value, Form, void>[];
export declare type FieldConfig<Value> = {
	init: Value | InitFieldValue<Value>;
	rules?: Rule<Value>[] | RuleResolver<Value, any>;
	filter?: Store<boolean> | FilterFunc<Value>;
	validateOn?: ValidationEvent[];
	units?: {
		$value?: Store<Value>;
		$errors?: Store<ValidationError<Value>[]>;
		$isTouched?: Store<boolean>;
		onChange?: Event<Value>;
		changed?: Event<Value>;
		onBlur?: Event<void>;
		addError?: Event<{
			rule: string;
			errorText?: string;
		}>;
		validate?: Event<void>;
		resetValue?: Event<void>;
		reset?: Event<void>;
		resetErrors?: Event<void>;
	};
};
export declare type AnyFields = {
	[key: string]: Field<any>;
};
export declare type AnyFormValues = {
	[key: string]: any;
};
export declare type FormValues<Fields extends AnyFields> = {
	[K in keyof Fields]: Fields[K] extends Field<infer U> ? U : never;
};
export declare type FormFieldConfigs<Values extends AnyFormValues> = {
	[K in keyof Values]: FieldConfig<Values[K]>;
};
export declare type FormFields<Values extends AnyFormValues> = {
	[K in keyof Values]: Field<Values[K]>;
};
export declare type FormConfig<Values extends AnyFormValues> = {
	fields: FormFieldConfigs<Values>;
	domain?: Domain;
	filter?: Store<boolean>;
	validateOn?: ValidationEvent[];
	units?: {
		submit?: Event<void>;
		validate?: Event<void>;
		reset?: Event<void>;
		resetValues?: Event<void>;
		resetTouched?: Event<void>;
		resetErrors?: Event<void>;
		formValidated?: Event<Values>;
		setForm?: Event<Partial<AnyFormValues>>;
	};
};
export declare type Form<Values extends AnyFormValues> = {
	fields: FormFields<Values>;
	$values: Store<Values>;
	$eachValid: Store<boolean>;
	$isValid: Store<boolean>;
	$isDirty: Store<boolean>;
	$touched: Store<boolean>;
	$meta: Store<{
		isValid: boolean;
		isDirty: boolean;
		touched: boolean;
	}>;
	submit: Event<void>;
	validate: Event<void>;
	reset: Event<void>;
	set: Event<Partial<Values>>;
	setForm: Event<Partial<Values>>;
	resetTouched: Event<void>;
	resetValues: Event<void>;
	resetErrors: Event<void>;
	formValidated: Event<Values>;
};
export declare function createForm<Values extends AnyFormValues>(config: FormConfig<Values>): Form<Values>;
export declare type ErrorTextMap = {
	[key: string]: string;
};
export declare type AddErrorPayload = {
	rule: string;
	errorText?: string;
};
export declare type ConnectedField<Value> = {
	name: string;
	value: Value;
	errors: ValidationError<Value>[];
	firstError: ValidationError<Value> | null;
	hasError: () => boolean;
	onChange: (v: Value) => Value;
	onBlur: (v: void) => void;
	errorText: (map?: ErrorTextMap) => string;
	addError: (p: AddErrorPayload) => AddErrorPayload;
	validate: (v: void) => void;
	isValid: boolean;
	isDirty: boolean;
	isTouched: boolean;
	touched: boolean;
	reset: (v: void) => void;
	set: (v: Value) => Value;
	resetErrors: (v: void) => void;
};
export declare type ConnectedFields<Values extends AnyFormValues> = {
	[K in keyof Values]: ConnectedField<Values[K]>;
};
export declare function useField<Value>(field: Field<Value>): ConnectedField<Value>;
export declare type Result<Values extends AnyFormValues> = {
	fields: ConnectedFields<Values>;
	values: Values;
	hasError: (fieldName?: keyof Values) => boolean;
	eachValid: boolean;
	isValid: boolean;
	isDirty: boolean;
	isTouched: boolean;
	touched: boolean;
	errors: (fieldName: keyof Values) => (ValidationError<Values[typeof fieldName]>[]);
	error: (fieldName: keyof Values) => (ValidationError<Values[typeof fieldName]>) | null;
	errorText: (fieldName: keyof Values, map?: ErrorTextMap) => string;
	submit: (p: void) => void;
	reset: (p: void) => void;
	setForm: (p: Partial<Values>) => Partial<Values>;
	set: (p: Partial<Values>) => Partial<Values>;
	formValidated: (p: Values) => Values;
};
export declare function useForm<Values extends AnyFormValues>(form: Form<Values>): Result<Values>;

export {};
