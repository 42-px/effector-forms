{"version":3,"file":"index.js","sources":["../src/create-form-unit.ts","../src/field.ts","../src/validation.ts","../src/ssr.ts","../src/factory.ts","../src/react-hooks.ts"],"sourcesContent":["import { createStore, createEvent, Domain, Store, Event } from \"effector\"\n\ntype CreateStoreParams<Value> = {\n  init: Value\n  domain?: Domain\n  existing?: Store<Value>\n}\n\nfunction store<Value>({ init, domain, existing }: CreateStoreParams<Value>) {\n    if (existing) {\n        return existing\n    }\n    return domain ? domain.store(init) : createStore(init)\n}\n\ntype CreateEventParams<Value> = {\n  domain?: Domain\n  existing?: Event<Value>\n}\n\nfunction event<Value>({ domain, existing }: CreateEventParams<Value>) {\n    if (existing) {\n        return existing\n    }\n    return domain ? domain.event<Value>() : createEvent<Value>()\n}\n\nexport const createFormUnit = {\n    store,\n    event,\n}\n","import {\n    createStore,\n    Domain,\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n    merge,\n} from \"effector\"\nimport {\n    ValidationError,\n    Field,\n    FieldData,\n    FieldConfig,\n    AnyFormValues,\n    ValidationEvent,\n    Rule,\n    RuleResolver,\n} from \"./types\"\nimport { createCombineValidator } from \"./validation\"\nimport { createFormUnit } from \"./create-form-unit\"\n\nexport function createField(\n    fieldName: string,\n    fieldConfig: FieldConfig<any>,\n    domain?: Domain,\n): Field<any> {\n    const initValue = typeof fieldConfig.init === \"function\"\n        ? fieldConfig.init()\n        : fieldConfig.init\n\n    const $value = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$value,\n        init: initValue,\n    })\n\n    const $errors = createFormUnit.store<ValidationError[]>({\n        domain,\n        existing: fieldConfig.units?.$errors,\n        init: [],\n    })\n\n\n    const $firstError = $errors.map(\n        (errors) => errors[0] ? errors[0] : null\n    )\n\n    const $isDirty = $value.map((value) => value !== initValue)\n\n    const $touched = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$isTouched,\n        init: false,\n    })\n\n    const onChange = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onChange,\n    })\n    const onBlur = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onBlur,\n    })\n    const changed = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.changed,\n    })\n    const addError = createFormUnit.event<{\n        rule: string\n        errorText?: string\n    }>({\n        domain,\n        existing: fieldConfig.units?.addError,\n    })\n    const validate = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.validate,\n    })\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetErrors,\n    })\n    const resetValue = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetValue,\n    })\n    const reset = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.reset,\n    })\n\n    const $isValid = $firstError.map((firstError) => firstError === null)\n\n    const $field = combine({\n        value: $value,\n        errors: $errors,\n        firstError: $firstError,\n        isValid: $isValid,\n        isDirty: $isDirty,\n        isTouched: $touched,\n    })\n\n    return {\n        changed,\n        name: fieldName,\n        $value,\n        $errors,\n        $firstError,\n        $isValid,\n        $isDirty,\n        $isTouched: $touched,\n        $touched,\n        $field: $field as Store<FieldData<any>>,\n        onChange,\n        onBlur,\n        addError,\n        validate,\n        set: onChange,\n        reset,\n        resetErrors,\n        resetValue,\n        filter: fieldConfig.filter,\n    }\n}\n\ntype BindValidationParams = {\n    $form: Store<AnyFormValues>\n    validateFormEvent: Event<void>\n    submitEvent: Event<void>\n    resetFormEvent: Event<void>\n    resetValues: Event<void>\n    resetErrors: Event<void>\n    field: Field<any>\n    rules: Rule<any, any>[] | RuleResolver<any, any>\n    formValidationEvents: ValidationEvent[]\n    fieldValidationEvents: ValidationEvent[]\n}\n\nexport function bindValidation({\n    $form,\n    validateFormEvent,\n    submitEvent,\n    resetFormEvent,\n    resetValues,\n    field,\n    rules,\n    resetErrors: resetErrorsFormEvent,\n    formValidationEvents,\n    fieldValidationEvents,\n}: BindValidationParams): void {\n    const {\n        $value,\n        $errors,\n        onBlur,\n        changed,\n        addError,\n        validate,\n        resetErrors,\n        resetValue,\n        reset,\n    } = field\n\n    const rulesSources = typeof rules === \"function\"\n        ? createStore<any[]>([])\n        : combine(rules.map(({ source }) => source || createStore(null)))\n\n    const validator = createCombineValidator(rules)\n    const eventsNames = [...formValidationEvents, ...fieldValidationEvents]\n    const validationEvents: Event<{\n        fieldValue: any\n        form: AnyFormValues\n        rulesSources: any[]\n    }>[] = []\n\n    if (eventsNames.includes(\"submit\")) {\n        const validationTrigger = sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: submitEvent,\n        })\n\n        validationEvents.push(validationTrigger)\n    }\n\n    if (eventsNames.includes(\"blur\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: onBlur,\n        }))\n    }\n\n    if (eventsNames.includes(\"change\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: merge(\n                [changed, resetValue, resetValues]\n            ),\n        }))\n    }\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: $form,\n            rulesSources,\n        }),\n        clock: validate,\n    }))\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: $form,\n            rulesSources,\n        }),\n        clock: validateFormEvent,\n    }))\n\n    const addErrorWithValue = sample({\n        source: $value,\n        clock: addError,\n        fn: (value, { rule, errorText }): ValidationError => ({\n            rule,\n            value,\n            errorText,\n        }),\n    })\n\n    $errors\n        .on(\n            validationEvents,\n            (_, { form, fieldValue, rulesSources }) => validator(\n                fieldValue,\n                form,\n                rulesSources,\n            )\n        )\n        .on(addErrorWithValue, (errors, newError) => [newError, ...errors])\n        .reset(resetErrors, resetFormEvent, reset, resetErrorsFormEvent)\n\n    if (!eventsNames.includes(\"change\")) {\n        $errors.reset(changed)\n    }\n}\n\nexport function bindChangeEvent(\n    {\n        $value,\n        $touched,\n        onChange,\n        changed,\n        name,\n        reset,\n        resetValue,\n        filter }: Field<any>,\n    setForm: Event<Partial<AnyFormValues>>,\n    resetForm: Event<void>,\n    resetTouched: Event<void>,\n    resetValues: Event<void>,\n): void {\n\n    $touched\n        .on(changed, () => true)\n        .reset(reset, resetForm, resetTouched)\n\n    guard({\n        source: onChange,\n        filter: filter || (() => true),\n        target: changed,\n    })\n\n    $value\n        .on(changed, (_, value) => value)\n        .on(\n            setForm,\n            (curr, updateSet) => updateSet.hasOwnProperty(name)\n                ? updateSet[name]\n                : curr\n        )\n        .reset(reset, resetValue, resetValues, resetForm)\n\n}\n","import { Store, combine } from \"effector\"\nimport {\n    ValidationError,\n    Rule,\n    AnyFields,\n    RuleResolver,\n} from \"./types\"\n\nexport function createCombineValidator<Value = any, Form = any>(\n    rulesOrResolver: Rule<Value, Form, any>[] | RuleResolver<Value, Form>\n) {\n    return (\n        value: Value,\n        form: Form,\n        rulesSources?: any[]\n    ): ValidationError<Value>[] => {\n\n        const errors: ValidationError<Value>[] = []\n        const rules = typeof rulesOrResolver === \"function\"\n            ? rulesOrResolver(value, form)\n            : rulesOrResolver\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i]\n            const source = rulesSources ? rulesSources[i] : null\n            const result = rule.validator(value, form, source)\n\n            if (typeof result === \"boolean\" && !result) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: rule.errorText,\n                    value,\n                })\n            }\n\n            if (typeof result === \"object\" && !result.isValid) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: result.errorText,\n                    value,\n                })\n            }\n        }\n\n        return errors\n    }\n}\n\n\nexport function eachValid(fields: AnyFields) {\n    const firstErrors: Store<ValidationError | null>[] = []\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        const { $firstError } = fields[fieldName]\n        firstErrors.push($firstError)\n    }\n  \n    const $firstErrors = combine(firstErrors)\n  \n    return $firstErrors.map((errors) => errors.every(error => error === null))\n}\n","import { Event } from \"effector\"\nimport { useEvent } from \"effector-react\"\n\nexport function isSSR() {\n    return process.env.SSR_BUILD === \"true\"\n}\n\nexport function wrapEvent<P>(event: Event<P>) {\n    return isSSR() ? useEvent(event) : event\n}\n\n\n","import {\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n} from \"effector\"\nimport {\n    FieldConfig,\n    Field,\n    AnyFields,\n    AnyFieldsConfigs,\n    AnyFormValues,\n    FormConfig,\n    FormValues,\n} from \"./types\"\nimport { eachValid } from \"./validation\"\nimport {\n    createField,\n    bindValidation,\n    bindChangeEvent,\n} from \"./field\"\nimport { createFormUnit } from \"./create-form-unit\"\nimport { isSSR } from \"./ssr\"\n\nfunction createFormValuesStore(\n    fields: AnyFields\n): Store<AnyFormValues> {\n    const shape: { [key: string]: Store<any> } = {}\n\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        shape[fieldName] = fields[fieldName].$value\n    }\n\n    return combine(shape)\n}\n\n\nexport type Form<Fields extends AnyFieldsConfigs> = {\n    fields: {\n        [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n        ? Field<U>\n        : never\n    }\n    $values: Store<FormValues<Fields>>\n    $eachValid: Store<boolean>\n    $isValid: Store<boolean>\n    $isDirty: Store<boolean>\n    $touched: Store<boolean>\n    $meta: Store<{\n        isValid: boolean\n        isDirty: boolean\n        touched: boolean\n    }>\n    submit: Event<void>\n    validate: Event<void>\n    reset: Event<void>\n    set: Event<Partial<FormValues<Fields>>>\n    setForm: Event<Partial<FormValues<Fields>>>\n    resetTouched: Event<void>\n    resetValues: Event<void>\n    resetErrors: Event<void>\n    formValidated: Event<FormValues<Fields>>\n}\n\n\nexport function createForm<Fields extends AnyFieldsConfigs>(\n    config: FormConfig<Fields>\n) {\n    const {\n        filter: $filter,\n        domain,\n        fields: fieldsConfigs,\n        validateOn,\n        units,\n    } = config\n\n    if (isSSR() && !domain) {\n        throw new Error(\"domain option is required in ssr mode!\")\n    }\n\n    const fields: AnyFields = {}\n\n    const dirtyFlagsArr: Store<boolean>[] = []\n    const touchedFlagsArr: Store<boolean>[] = []\n\n    // create units\n    for (const fieldName in fieldsConfigs) {\n        if (!fieldsConfigs.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n\n        const field = createField(fieldName, fieldConfig, domain)\n\n        fields[fieldName] = field\n        dirtyFlagsArr.push(field.$isDirty)\n        touchedFlagsArr.push(field.$touched)\n    }\n\n    const $form = createFormValuesStore(fields)\n    const $eachValid = eachValid(fields)\n    const $isFormValid = $filter\n        ? combine($eachValid, $filter, (valid, filter) => valid && filter)\n        : $eachValid\n    const $isDirty = combine(dirtyFlagsArr).map(\n        (dirtyFlags) => dirtyFlags.some(Boolean)\n    )\n    const $touched = combine(touchedFlagsArr).map(\n        (touchedFlags) => touchedFlags.some(Boolean)\n    )\n\n    const $meta = combine({\n        isValid: $eachValid,\n        isDirty: $isDirty,\n        touched: $touched,\n    })\n\n    const validate = createFormUnit.event<void>({\n        domain,\n        existing: units?.validate,\n    })\n\n    const submitForm = createFormUnit.event<void>({\n        domain,\n        existing: units?.submit,\n    })\n\n    const formValidated = createFormUnit.event({\n        domain,\n        existing: units?.formValidated,\n    })\n\n\n    const setForm = createFormUnit.event<Partial<AnyFormValues>>({\n        domain,\n        existing: units?.setForm as Event<Partial<AnyFormValues>>,\n    })\n\n    const resetForm = createFormUnit.event({\n        domain,\n        existing: units?.reset,\n    })\n\n    const resetValues = createFormUnit.event({\n        domain,\n        existing: units?.resetValues,\n    })\n\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: units?.resetErrors,\n    })\n\n    const resetTouched = createFormUnit.event({\n        domain,\n        existing: units?.resetTouched,\n    })\n\n    const submitWithFormData = sample($form, submitForm)\n    const validateWithFormData = sample($form, validate)\n\n    // bind units\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n        const field = fields[fieldName]\n\n        bindChangeEvent(field, setForm, resetForm, resetTouched, resetValues)\n\n        if (!fieldConfig.rules) continue\n\n        bindValidation({\n            $form,\n            rules: fieldConfig.rules,\n            submitEvent: submitForm,\n            resetFormEvent: resetForm,\n            resetValues,\n            resetErrors,\n            validateFormEvent: validate,\n            field,\n            formValidationEvents: validateOn ? validateOn : [\"submit\"],\n            fieldValidationEvents: fieldConfig.validateOn\n                ? fieldConfig.validateOn\n                : [],\n        })\n    }\n\n    guard({\n        source: submitWithFormData as unknown as Event<FormValues<Fields>>,\n        filter: $isFormValid,\n        // TODO: fix\n        target: formValidated,\n    })\n\n    guard({\n        source: validateWithFormData as unknown as Event<FormValues<Fields>>,\n        filter: $isFormValid,\n        target: formValidated,\n    })\n\n    return {\n        fields,\n        $values: $form,\n        $eachValid,\n        $isValid: $eachValid,\n        $isDirty: $isDirty,\n        $touched: $touched,\n        $meta,\n        submit: submitForm,\n        validate,\n        resetTouched,\n        reset: resetForm,\n        resetValues,\n        resetErrors,\n        setForm,\n        set: setForm,\n        formValidated,\n    } as unknown as Form<Fields>\n}\n","import { useStore } from \"effector-react\"\nimport { Form } from \"./factory\"\nimport {\n    Field,\n    FormValues,\n    ValidationError,\n    FieldConfig,\n    AnyFieldsConfigs,\n    AnyFormValues\n} from \"./types\"\nimport { wrapEvent } from \"./ssr\"\n\ntype ErrorTextMap = {\n  [key: string]: string\n}\n\ntype AddErrorPayload = { rule: string; errorText?: string }\n\ntype ConnectedField<Value> = {\n  name: string\n  value: Value\n  errors: ValidationError<Value>[]\n  firstError: ValidationError<Value> | null\n  hasError: () => boolean\n  onChange: (v: Value) => Value\n  onBlur: (v: void) => void\n  errorText: (map?: ErrorTextMap) => string\n  addError: (p: AddErrorPayload) => AddErrorPayload\n  validate: (v: void) => void\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  reset: (v: void) => void\n  set: (v: Value) => Value\n  resetErrors: (v: void) => void\n}\n\ntype ConnectedFields<Fields extends AnyFieldsConfigs> = {\n  [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n  ? ConnectedField<U>\n  : never\n}\n\ntype AnyConnectedFields = {\n  [key: string]: ConnectedField<any>\n}\n\nexport function useField<Value>(field: Field<Value>): ConnectedField<Value> {\n    const {\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        isTouched: touched,\n    } = useStore(field.$field)\n\n    return {\n        name: field.name,\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        touched,\n        isTouched: touched,\n        onChange: wrapEvent(field.onChange),\n        onBlur: wrapEvent(field.onBlur),\n        addError: wrapEvent(field.addError),\n        validate: wrapEvent(field.validate),\n        reset: wrapEvent(field.reset),\n        set: wrapEvent(field.onChange),\n        resetErrors: wrapEvent(field.resetErrors),\n        hasError: () => {\n            return firstError !== null\n        },\n        errorText: (map) => {\n            if (!firstError) {\n                return \"\"\n            }\n            if (!map) {\n                return firstError.errorText || \"\"\n            }\n            if (map[firstError.rule]) {\n                return map[firstError.rule]\n            }\n            return firstError.errorText || \"\"\n        }\n    }\n\n}\n\ntype Result<Fields extends AnyFieldsConfigs> = {\n  fields: ConnectedFields<Fields>\n  values: FormValues<Fields>\n  hasError: (fieldName?: keyof Fields) => boolean\n  eachValid: boolean\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  errors: (fieldName: keyof Fields) => (\n    // eslint-disable-next-line max-len\n    Fields[typeof fieldName] extends FieldConfig<infer U> ? ValidationError<U>[] : never\n  )\n  error: (fieldName: keyof Fields) => (\n    // eslint-disable-next-line max-len\n    Fields[typeof fieldName] extends FieldConfig<infer U> ? ValidationError<U> : never\n  ) | null\n  errorText: (fieldName: keyof Fields, map?: ErrorTextMap) => string\n  submit: (p: void) => void\n  reset: (p: void) => void\n  setForm: (p: Partial<FormValues<Fields>>) => Partial<FormValues<Fields>>\n  set: (p: Partial<FormValues<Fields>>) => Partial<FormValues<Fields>>\n  formValidated: (p: FormValues<Fields>) => FormValues<Fields>\n}\n\nexport function useForm<Fields extends AnyFieldsConfigs>(\n    form: Form<Fields>\n): Result<Fields> {\n    const connectedFields = {} as AnyConnectedFields\n    const values = {} as AnyFormValues\n\n    for (const fieldName in form.fields) {\n        if (!form.fields.hasOwnProperty(fieldName)) continue \n        const field = form.fields[fieldName]\n        const connectedField = useField(field)\n        connectedFields[fieldName] = connectedField\n        values[fieldName] = connectedField.value\n    }\n\n    const {\n        isValid: eachValid,\n        isDirty,\n        touched,\n    } = useStore(form.$meta)\n\n\n    const hasError = (fieldName?: string): boolean => {\n        if (!fieldName) {\n            return !eachValid\n        }\n        if (connectedFields[fieldName]) {\n            return Boolean(connectedFields[fieldName].firstError)\n        }\n        return false\n    }\n\n    const error = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].firstError\n        }\n        return null\n    }\n\n    const errors = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].errors\n        }\n        return []\n    }\n\n    const errorText = (fieldName: string, map?: ErrorTextMap) => {\n        const field = connectedFields[fieldName]\n        if (!field) {\n            return \"\"\n        }\n        if (!field.firstError) {\n            return \"\"\n        }\n        if (!map) {\n            return field.firstError.errorText || \"\"\n        }\n        if (map[field.firstError.rule]) {\n            return map[field.firstError.rule]\n        }\n        return field.firstError.errorText || \"\"\n    }\n\n    return {\n        fields: connectedFields as ConnectedFields<Fields>,\n        values,\n        hasError,\n        eachValid,\n        isValid: eachValid,\n        isDirty,\n        isTouched: touched,\n        touched,\n        errors,\n        error,\n        reset: wrapEvent(form.reset),\n        errorText,\n        submit: wrapEvent(form.submit),\n        setForm: wrapEvent(form.setForm),\n        set: wrapEvent(form.setForm), // set form alias\n        formValidated: wrapEvent(form.formValidated),\n    } as Result<Fields>\n}\n"],"names":["createFormUnit","store","init","domain","existing","createStore","event","createEvent","createField","fieldName","fieldConfig","initValue","$value","units","_fieldConfig$units","$errors","_fieldConfig$units2","$firstError","map","errors","$isDirty","value","$touched","_fieldConfig$units3","$isTouched","onChange","_fieldConfig$units4","onBlur","_fieldConfig$units5","changed","_fieldConfig$units6","addError","_fieldConfig$units7","validate","_fieldConfig$units8","resetErrors","_fieldConfig$units9","resetValue","_fieldConfig$units10","reset","_fieldConfig$units11","$isValid","firstError","name","$field","combine","isValid","isDirty","isTouched","set","filter","bindValidation","$form","validateFormEvent","submitEvent","resetFormEvent","resetValues","field","rules","resetErrorsFormEvent","formValidationEvents","fieldValidationEvents","rulesSources","source","validator","rulesOrResolver","form","i","length","rule","result","push","errorText","eventsNames","validationEvents","includes","validationTrigger","sample","fieldValue","clock","merge","addErrorWithValue","fn","on","_","newError","bindChangeEvent","setForm","resetForm","resetTouched","guard","target","curr","updateSet","hasOwnProperty","wrapEvent","useEvent","createForm","config","$filter","fields","fieldsConfigs","validateOn","Error","dirtyFlagsArr","touchedFlagsArr","shape","createFormValuesStore","$eachValid","firstErrors","every","error","eachValid","$isFormValid","valid","dirtyFlags","some","Boolean","touchedFlags","$meta","touched","submitForm","submit","formValidated","submitWithFormData","validateWithFormData","$values","useField","useStore","hasError","useForm","connectedFields","values","connectedField"],"mappings":"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"}