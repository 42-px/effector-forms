{"version":3,"file":"index.js","sources":["../src/create-form-unit.ts","../src/field.ts","../src/validation.ts","../src/factory.ts","../src/react-hooks.ts"],"sourcesContent":["import { createStore, createEvent, Domain, Store, Event } from \"effector\"\n\ntype CreateStoreParams<Value> = {\n  init: Value\n  domain?: Domain\n  existing?: Store<Value>\n}\n\nfunction store<Value>({ init, domain, existing }: CreateStoreParams<Value>) {\n    if (existing) {\n        return existing\n    }\n    return domain ? domain.store(init) : createStore(init)\n}\n\ntype CreateEventParams<Value> = {\n  domain?: Domain\n  existing?: Event<Value>\n}\n\nfunction event<Value>({ domain, existing }: CreateEventParams<Value>) {\n    if (existing) {\n        return existing\n    }\n    return domain ? domain.event<Value>() : createEvent<Value>()\n}\n\nexport const createFormUnit = {\n    store,\n    event,\n}\n","import {\n    createStore,\n    Domain,\n    Event,\n    Store,\n    combine, \n    sample,\n    guard,\n    merge,\n} from \"effector\"\nimport {\n    ValidationError,\n    Field,\n    FieldConfig,\n    AnyFormValues,\n    ValidationEvent,\n    Rule,\n    RuleResolver,\n} from \"./types\"\nimport { createCombineValidator } from \"./validation\"\nimport { createFormUnit } from \"./create-form-unit\"\n\nexport function createField(\n    fieldName: string,\n    fieldConfig: FieldConfig<any>,\n    domain?: Domain,\n): Field<any> {\n    const initValue = typeof fieldConfig.init === \"function\"\n        ? fieldConfig.init()\n        : fieldConfig.init\n\n    const $value = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$value,\n        init: initValue,\n    })\n\n    const $errors = createFormUnit.store<ValidationError[]>({\n        domain,\n        existing: fieldConfig.units?.$errors,\n        init: [],\n    })\n    \n\n    const $firstError = $errors.map(\n        (errors) => errors[0] ? errors[0] : null\n    )\n\n    const $isDirty = $value.map((value) => value !== initValue)\n\n    const $touched = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$isTouched,\n        init: false,\n    })\n\n    const onChange = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onChange,\n    })\n    const onBlur = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onBlur,\n    })\n    const changed = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.changed,\n    })\n    const addError = createFormUnit.event<{\n        rule: string\n        errorText?: string \n    }>({\n        domain,\n        existing: fieldConfig.units?.addError,\n    })\n    const validate = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.validate,\n    })\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetErrors,\n    })\n    const resetValue = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetValue,\n    })\n    const reset = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.reset,\n    })\n\n    return {\n        changed,\n        name: fieldName,\n        $value,\n        $errors,\n        $firstError,\n        $isValid: $firstError.map((firstError) => firstError === null),\n        $isDirty,\n        $isTouched: $touched,\n        $touched,\n        onChange,\n        onBlur,\n        addError,\n        validate,\n        set: onChange,\n        reset,\n        resetErrors,\n        resetValue,\n        filter: fieldConfig.filter,\n    }\n}\n\ntype BindValidationParams = {\n  $form: Store<AnyFormValues>\n  validateFormEvent: Event<void>\n  submitEvent: Event<void>\n  resetFormEvent: Event<void>\n  resetValues: Event<void>\n  resetErrors: Event<void>\n  field: Field<any>\n  rules: Rule<any, any>[] | RuleResolver<any, any>\n  formValidationEvents: ValidationEvent[]\n  fieldValidationEvents: ValidationEvent[]\n}\n\nexport function bindValidation({\n    $form,\n    validateFormEvent,\n    submitEvent,\n    resetFormEvent,\n    resetValues,\n    field,\n    rules,\n    resetErrors: resetErrorsFormEvent,\n    formValidationEvents,\n    fieldValidationEvents,\n}: BindValidationParams): void {\n    const {\n        $value,\n        $errors,\n        onBlur,\n        changed,\n        addError,\n        validate,\n        resetErrors,\n        resetValue,\n        reset,\n    } = field\n\n    const rulesSources = typeof rules === \"function\" \n        ? createStore<any[]>([])\n        : combine(rules.map(({ source }) => source || createStore(null)))\n\n    const validator = createCombineValidator(rules)\n    const eventsNames = [...formValidationEvents, ...fieldValidationEvents]\n    const validationEvents: Event<{\n        fieldValue: any\n        form: AnyFormValues\n        rulesSources: any[]\n    }>[] = []\n\n    if (eventsNames.includes(\"submit\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: submitEvent,\n        }))\n    }\n\n    if (eventsNames.includes(\"blur\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: onBlur,\n        }))\n    }\n\n    if (eventsNames.includes(\"change\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: merge(\n                [changed, resetValue, resetValues]\n            ),\n        }))\n    }\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: $form,\n            rulesSources,\n        }),\n        clock: validate,\n    }))\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: $form,\n            rulesSources,\n        }),\n        clock: validateFormEvent,\n    }))\n\n    const addErrorWithValue = sample({\n        source: $value,\n        clock: addError,\n        fn: (value, { rule, errorText }): ValidationError => ({\n            rule,\n            value,\n            errorText,\n        }),  \n    })\n\n    $errors\n        .on(\n            validationEvents,\n            (_, { form, fieldValue, rulesSources }) => validator(\n                fieldValue,\n                form,\n                rulesSources,\n            )\n        )\n        .on(addErrorWithValue, (errors, newError) => [newError, ...errors])\n        .reset(resetErrors, resetFormEvent, reset, resetErrorsFormEvent)\n\n    if (!eventsNames.includes(\"change\")) {\n        $errors.reset(changed)\n    }\n}\n\nexport function bindChangeEvent(\n    {\n        $value,\n        $touched,\n        onChange,\n        changed,\n        name,\n        reset,\n        resetValue, \n        filter }: Field<any>,\n    setForm: Event<Partial<AnyFormValues>>,\n    resetForm: Event<void>,\n    resetTouched: Event<void>,\n    resetValues: Event<void>,\n): void {\n\n    $touched\n        .on(changed, () => true)\n        .reset(reset, resetForm, resetTouched)\n\n    guard({\n        source: onChange,\n        filter: filter || (() => true),\n        target: changed,\n    })\n\n    $value\n        .on(changed, (_, value) => value)\n        .on(\n            setForm,\n            (curr, updateSet) => updateSet.hasOwnProperty(name) \n                ? updateSet[name] \n                : curr\n        )\n        .reset(reset, resetValue, resetValues, resetForm)\n    \n}\n","import { Store, combine } from \"effector\"\nimport {\n    ValidationError,\n    Rule,\n    AnyFields,\n    RuleResolver,\n} from \"./types\"\n\nexport function createCombineValidator<Value = any, Form = any>(\n    rulesOrResolver: Rule<Value, Form, any>[] | RuleResolver<Value, Form>\n) {\n    return (\n        value: Value,\n        form: Form,\n        rulesSources?: any[]\n    ): ValidationError<Value>[] => {\n\n        const errors: ValidationError<Value>[] = []\n        const rules = typeof rulesOrResolver === \"function\"\n        ? rulesOrResolver(value, form)\n        : rulesOrResolver\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i]\n            const source = rulesSources ? rulesSources[i] : null\n            const result = rule.validator(value, form, source)\n\n            if (typeof result === \"boolean\" && !result) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: rule.errorText,\n                    value,\n                })\n            }\n\n            if (typeof result === \"object\" && !result.isValid) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: result.errorText,\n                    value,\n                })\n            }\n        }\n\n        return errors\n    }\n}\n\n\nexport function eachValid(fields: AnyFields) {\n    const firstErrors: Store<ValidationError | null>[] = []\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        const { $firstError } = fields[fieldName]\n        firstErrors.push($firstError)\n    }\n  \n    const $firstErrors = combine(firstErrors)\n  \n    return $firstErrors.map((errors) => errors.every(error => error === null))\n}\n","import {\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n} from \"effector\"\nimport {\n    FieldConfig,\n    Field,\n    AnyFields,\n    AnyFieldsConfigs,\n    AnyFormValues,\n    FormConfig,\n    FormValues,\n} from \"./types\"\nimport { eachValid } from \"./validation\"\nimport {\n    createField,\n    bindValidation,\n    bindChangeEvent,\n} from \"./field\"\nimport { createFormUnit } from \"./create-form-unit\"\nimport { isSSR } from \"./ssr\"\n\nfunction createFormValuesStore(\n    fields: AnyFields\n): Store<AnyFormValues> {\n    const shape: { [key: string]: Store<any> } = {}\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        shape[fieldName] = fields[fieldName].$value\n    }\n\n    return combine(shape)\n}\n\n\nexport type Form<Fields extends AnyFieldsConfigs> = {\n  fields: {\n    [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n      ? Field<U>\n      : never\n  }\n  $values: Store<FormValues<Fields>>\n  $eachValid: Store<boolean>\n  $isValid: Store<boolean>\n  $isDirty: Store<boolean>\n  $touched: Store<boolean>\n  submit: Event<void>\n  validate: Event<void>\n  reset: Event<void>\n  set: Event<Partial<FormValues<Fields>>>\n  setForm: Event<Partial<FormValues<Fields>>>\n  resetTouched: Event<void>\n  resetValues: Event<void>\n  resetErrors: Event<void>\n  formValidated: Event<FormValues<Fields>>\n}\n\n\nexport function createForm<Fields extends AnyFieldsConfigs>(\n    config: FormConfig<Fields>\n) {\n    const {\n        filter: $filter,\n        domain,\n        fields: fieldsConfigs,\n        validateOn,\n        units,\n    } = config\n\n    if (isSSR() && !domain) {\n        throw new Error(\"domain option is required in ssr mode!\")\n    }\n\n    const fields: AnyFields = {}\n\n    const dirtyFlagsArr: Store<boolean>[] = []\n    const touchedFlagsArr: Store<boolean>[] = []\n \n    // create units\n    for (const fieldName in fieldsConfigs) {\n        if (!fieldsConfigs.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n\n        const field = createField(fieldName, fieldConfig, domain)\n\n        fields[fieldName] = field\n        dirtyFlagsArr.push(field.$isDirty)\n        touchedFlagsArr.push(field.$touched)\n    }\n\n    const $form = createFormValuesStore(fields)\n    const $eachValid = eachValid(fields)\n    const $isFormValid = $filter\n        ? combine($eachValid, $filter, (valid, filter) => valid && filter)\n        : $eachValid\n    const $isDirty = combine(dirtyFlagsArr).map(\n        (dirtyFlags) => dirtyFlags.some(Boolean)\n    )\n    const $touched = combine(touchedFlagsArr).map(\n        (touchedFlags) => touchedFlags.some(Boolean)\n    )\n\n    const validate = createFormUnit.event<void>({\n        domain,\n        existing: units?.validate,\n    })\n  \n    const submitForm = createFormUnit.event<void>({\n        domain,\n        existing: units?.submit,\n    })\n    \n    const formValidated = createFormUnit.event({\n        domain,\n        existing: units?.formValidated,\n    })\n\n\n    const setForm = createFormUnit.event<Partial<AnyFormValues>>({\n        domain,\n        existing: units?.setForm as Event<Partial<AnyFormValues>>,\n    })\n    \n    const resetForm = createFormUnit.event({\n        domain,\n        existing: units?.reset,\n    })\n\n    const resetValues = createFormUnit.event({\n        domain,\n        existing: units?.resetValues,\n    })\n\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: units?.resetErrors,\n    })\n    \n    const resetTouched = createFormUnit.event({\n        domain,\n        existing: units?.resetTouched,\n    })\n    \n    const submitWithFormData = sample($form, submitForm)\n    const validateWithFormData = sample($form, validate)\n\n    // bind units\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n        const field = fields[fieldName]\n\n        bindChangeEvent(field, setForm, resetForm, resetTouched, resetValues)\n\n        if (!fieldConfig.rules) continue\n\n        bindValidation({\n            $form,\n            rules: fieldConfig.rules,\n            submitEvent: submitForm,\n            resetFormEvent: resetForm,\n            resetValues,\n            resetErrors,\n            validateFormEvent: validate,\n            field,\n            formValidationEvents: validateOn ? validateOn : [\"submit\"],\n            fieldValidationEvents: fieldConfig.validateOn\n                ? fieldConfig.validateOn \n                : [],\n        })\n    }\n\n    guard({\n        source: submitWithFormData as unknown as Event<FormValues<Fields>>,\n        filter: $isFormValid,\n        target: formValidated,\n    })\n\n    guard({\n        source: validateWithFormData as unknown as Event<FormValues<Fields>>,\n        filter: $isFormValid,\n        target: formValidated,\n    })\n\n    return {\n        fields,\n        $values: $form,\n        $eachValid,\n        $isValid: $eachValid,\n        $isDirty: $isDirty,\n        $touched: $touched,\n        submit: submitForm,\n        validate,\n        resetTouched,\n        reset: resetForm,\n        resetValues,\n        resetErrors,\n        setForm,\n        set: setForm,\n        formValidated,\n    } as unknown as Form<Fields>\n}\n","import { useStore } from \"effector-react\"\nimport { Event } from \"effector\"\nimport { Form } from \"./factory\"\nimport {\n    Field,\n    FormValues,\n    ValidationError,\n    FieldConfig,\n    AnyFieldsConfigs\n} from \"./types\"\n\ntype ErrorTextMap = {\n  [key: string]: string\n}\n\ntype ConnectedField<Value> = {\n  name: string\n  value: Value\n  errors: ValidationError<Value>[]\n  firstError: ValidationError<Value> | null\n  hasError: () => boolean\n  onChange: Event<Value>\n  onBlur: Event<void>\n  errorText: (map?: ErrorTextMap) => string\n  addError: Event<{ rule: string; errorText?: string }>\n  validate: Event<void>\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  reset: Event<void>\n  set: Event<Value>\n  resetErrors: Event<void>\n}\n\ntype ConnectedFields<Fields extends AnyFieldsConfigs> = {\n  [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n  ? ConnectedField<U>\n  : never\n}\n\ntype AnyConnectedFields = {\n  [key: string]: ConnectedField<any>\n}\n\nexport function useField<Value>(field: Field<Value>): ConnectedField<Value> {\n    const value = useStore(field.$value)\n    const errors = useStore(field.$errors)\n    const firstError = useStore(field.$firstError)\n    const isValid = useStore(field.$isValid)\n    const isDirty = useStore(field.$isDirty)\n    const touched = useStore(field.$touched)\n\n    return {\n        name: field.name,\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        touched,\n        isTouched: touched,\n        onChange: field.onChange,\n        onBlur: field.onBlur,\n        addError: field.addError,\n        validate: field.validate,\n        reset: field.reset,\n        set: field.onChange,\n        resetErrors: field.resetErrors,\n        hasError: () => {\n            return firstError !== null\n        },\n        errorText: (map) => {\n            if (!firstError) {\n                return \"\"\n            }\n            if (!map) {\n                return firstError.errorText || \"\"\n            }\n            if (map[firstError.rule]) {\n                return map[firstError.rule]\n            }\n            return firstError.errorText || \"\"\n        }\n    }\n\n}\n\ntype Result<Fields extends AnyFieldsConfigs> = {\n  fields: ConnectedFields<Fields>\n  values: FormValues<Fields>\n  hasError: (fieldName?: keyof Fields) => boolean\n  eachValid: boolean\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  errors: (fieldName: keyof Fields) => (\n    // eslint-disable-next-line max-len\n    Fields[typeof fieldName] extends FieldConfig<infer U> ? ValidationError<U>[] : never\n  )\n  error: (fieldName: keyof Fields) => (\n    // eslint-disable-next-line max-len\n    Fields[typeof fieldName] extends FieldConfig<infer U> ? ValidationError<U> : never\n  ) | null\n  errorText: (fieldName: keyof Fields, map?: ErrorTextMap) => string\n  submit: Event<void>\n  reset: Event<void>\n  setForm: Event<Partial<FormValues<Fields>>>\n  set: Event<Partial<FormValues<Fields>>>\n  formValidated: Event<FormValues<Fields>>\n}\n\nexport function useForm<Fields extends AnyFieldsConfigs>(\n    form: Form<Fields>\n) {\n    const connectedFields = {} as AnyConnectedFields\n\n    for (const fieldName in form.fields) {\n        if (!form.fields.hasOwnProperty(fieldName)) continue \n        const field = form.fields[fieldName]\n\n        connectedFields[fieldName] = useField(field)\n    }\n\n    const values = useStore(form.$values)\n    const eachValid = useStore(form.$eachValid)\n    const isDirty = useStore(form.$isDirty)\n    const touched = useStore(form.$touched)\n\n\n    const hasError = (fieldName?: string): boolean => {\n        if (!fieldName) {\n            return !eachValid\n        }\n        if (connectedFields[fieldName]) {\n            return Boolean(connectedFields[fieldName].firstError)\n        }\n        return false\n    }\n\n    const error = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].firstError\n        }\n        return null\n    }\n\n    const errors = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].errors\n        }\n        return []\n    }\n\n    const errorText = (fieldName: string, map?: ErrorTextMap) => {\n        const field = connectedFields[fieldName]\n        if (!field) {\n            return \"\"\n        }\n        if (!field.firstError) {\n            return \"\"\n        }\n        if (!map) {\n            return field.firstError.errorText || \"\"\n        }\n        if (map[field.firstError.rule]) {\n            return map[field.firstError.rule]\n        }\n        return field.firstError.errorText || \"\"\n    }\n\n    return {\n        fields: connectedFields as ConnectedFields<Fields>,\n        values,\n        hasError,\n        eachValid,\n        isValid: eachValid,\n        isDirty,\n        isTouched: touched,\n        touched,\n        errors,\n        error,\n        reset: form.reset,\n        errorText,\n        submit: form.submit,\n        setForm: form.setForm,\n        set: form.setForm, // set form alias\n        formValidated: form.formValidated,\n    } as Result<Fields>\n}\n"],"names":["createFormUnit","store","init","domain","existing","createStore","event","createEvent","createField","fieldName","fieldConfig","initValue","$value","units","$errors","$firstError","map","errors","$isDirty","value","$touched","$isTouched","onChange","onBlur","changed","addError","validate","resetErrors","resetValue","reset","name","$isValid","firstError","set","filter","bindValidation","rulesOrResolver","$form","validateFormEvent","submitEvent","resetFormEvent","resetValues","field","rules","resetErrorsFormEvent","formValidationEvents","fieldValidationEvents","rulesSources","combine","source","validator","form","i","length","rule","result","push","errorText","_typeof","isValid","eventsNames","validationEvents","includes","sample","fieldValue","clock","merge","addErrorWithValue","fn","on","_","newError","bindChangeEvent","setForm","resetForm","resetTouched","guard","target","curr","updateSet","hasOwnProperty","createForm","config","$filter","fieldsConfigs","fields","validateOn","Error","dirtyFlagsArr","touchedFlagsArr","shape","createFormValuesStore","$eachValid","firstErrors","every","error","eachValid","$isFormValid","valid","dirtyFlags","some","Boolean","touchedFlags","submitForm","submit","formValidated","submitWithFormData","validateWithFormData","$values","useField","useStore","isDirty","touched","isTouched","hasError","useForm","connectedFields","values"],"mappings":"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"}