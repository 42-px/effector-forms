{"version":3,"file":"effector-forms.umd.js","sources":["../src/field.ts","../src/validation.ts","../src/react-hooks.ts","../src/factory.ts"],"sourcesContent":["import {\n    Domain,\n    Event,\n    Store,\n    createStore,\n    createEvent,\n    combine, \n    sample,\n} from \"effector\"\nimport {\n    ValidationError,\n    Field,\n    FieldConfig,\n    AnyFormValues,\n    ValidationEvent,\n    Rule,\n} from \"./types\"\nimport { createCombineValidator } from \"./validation\"\n\nexport function createField(\n    fieldName: string,\n    fieldConfig: FieldConfig<any>,\n    domain?: Domain,\n): Field<any> {\n    const initValue = typeof fieldConfig.init === \"function\"\n        ? fieldConfig.init()\n        : fieldConfig.init\n\n    const $value = domain ? domain.store(initValue) : createStore(initValue)\n\n    const $errors = domain\n        ? domain.store<ValidationError[]>([])\n        : createStore<ValidationError[]>([])\n\n    const $firstError = $errors.map(\n        (errors) => errors[0] ? errors[0] : null\n    )\n\n    const onChange = domain ? domain.event() : createEvent()\n    const onBlur = domain ? domain.event() : createEvent()\n    const addError = domain\n        ? domain.event<{ rule: string; errorText?: string }>()\n        : createEvent<{ rule: string; errorText?: string }>()\n    const validate = domain ? domain.event() : createEvent()\n    const resetErrors = domain ? domain.event() : createEvent()\n    const reset = domain ? domain.event() : createEvent()\n\n    return {\n        name: fieldName,\n        $value,\n        $errors,\n        $firstError,\n        $isValid: $firstError.map((firstError) => firstError === null),\n        onChange,\n        onBlur,\n        addError,\n        validate,\n        set: onChange,\n        reset,\n        resetErrors,\n    }\n}\n\ntype BindValidationParams = {\n  $form: Store<AnyFormValues>\n  submitEvent: Event<void>\n  field: Field<any>\n  rules: Rule<any, any>[]\n  formValidationEvents: ValidationEvent[]\n  fieldValidationEvents: ValidationEvent[]\n}\n\nexport function bindValidation({\n    $form,\n    submitEvent,\n    field,\n    rules,\n    formValidationEvents,\n    fieldValidationEvents\n}: BindValidationParams): void {\n    const {\n        $value,\n        $errors,\n        onBlur,\n        onChange,\n        addError,\n        validate,\n        resetErrors\n    } = field\n    const validator = createCombineValidator(rules)\n    const eventsNames = [...formValidationEvents, ...fieldValidationEvents]\n    const validationEvents: Event<{\n        fieldValue: any\n        form: AnyFormValues\n    }>[] = []\n\n    if (eventsNames.includes(\"submit\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n            }),\n            clock: submitEvent,\n        }))\n    }\n\n    if (eventsNames.includes(\"blur\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n            }),\n            clock: onBlur,\n        }))\n    }\n\n    if (eventsNames.includes(\"change\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n            }),\n            clock: onChange,\n        }))\n    }\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: $form,\n        }),\n        clock: validate,\n    }))\n\n    const addErrorWithValue = sample({\n        source: $value,\n        clock: addError,\n        fn: (value, { rule, errorText }): ValidationError => ({\n            rule,\n            value,\n            errorText,\n        }),  \n    })\n\n    $errors\n        .on(\n            validationEvents,\n            (_, { form, fieldValue }) => validator(fieldValue, form)\n        )\n        .on(addErrorWithValue, (errors, newError) => [newError, ...errors])\n        .reset(resetErrors)\n\n    if (!eventsNames.includes(\"change\")) {\n        $errors.reset(onChange)\n    }\n}\n\nexport function bindChangeEvent(\n    { $value, onChange, name, reset }: Field<any>,\n    setForm: Event<Partial<AnyFormValues>>,\n    resetForm: Event<void>,\n): void {\n\n    $value\n        .on(onChange, (_, value) => value)\n        .on(\n            setForm,\n            (curr, updateSet) => updateSet.hasOwnProperty(name) \n                ? updateSet[name] \n                : curr\n        )\n        .reset(reset, resetForm)\n    \n}\n","import { Store, combine } from \"effector\"\nimport {\n    ValidationError,\n    Rule,\n    AnyFields,\n} from \"./types\"\n\nexport function createCombineValidator<Value = any, Form = any>(\n    rules: Rule<Value, Form>[]\n) {\n    return (value: Value, form?: Form): ValidationError<Value>[] => {\n\n        const errors: ValidationError<Value>[] = []\n\n        for (const rule of rules) {\n            const result = rule.validator(value, form)\n\n            if (typeof result === \"boolean\" && !result) {\n                errors.push({\n                    rule: rule.name,\n                    value,\n                })\n            }\n\n            if (typeof result === \"object\" && !result.isValid) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: result.errorText,\n                    value,\n                })\n            }\n        }\n\n        return errors\n    }\n}\n\n\nexport function eachValid(fields: AnyFields) {\n    const firstErrors: Store<ValidationError | null>[] = []\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        const { $firstError } = fields[fieldName]\n        firstErrors.push($firstError)\n    }\n  \n    const $firstErrors = combine(firstErrors)\n  \n    return $firstErrors.map((errors) => errors.every(error => error === null))\n}\n","import { useStore } from \"effector-react\"\nimport { Event } from \"effector\"\nimport { Form, FormValues } from \"./factory\"\nimport {\n    Field,\n    ValidationError,\n    FieldConfig,\n    AnyFieldsConfigs\n} from \"./types\"\n\ntype ErrorTextMap = {\n  [key: string]: string\n}\n\ntype ConnectedField<Value> = {\n  name: string\n  value: Value\n  errors: ValidationError<Value>[]\n  firstError: ValidationError<Value> | null\n  hasError: () => boolean\n  onChange: Event<Value>\n  onBlur: Event<void>\n  errorText: (map?: ErrorTextMap) => string\n  addError: Event<{ rule: string; errorText?: string }>\n  validate: Event<void>\n  isValid: boolean\n  reset: Event<void>\n  set: Event<Value>\n  resetErrors: Event<void>\n}\n\ntype ConnectedFields<Fields extends AnyFieldsConfigs> = {\n  [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n  ? ConnectedField<U>\n  : never\n}\n\ntype AnyConnectedFields = {\n  [key: string]: ConnectedField<any>\n}\n\nexport function useField<Value>(field: Field<Value>): ConnectedField<Value> {\n    const value = useStore(field.$value)\n    const errors = useStore(field.$errors)\n    const firstError = useStore(field.$firstError)\n    const isValid = useStore(field.$isValid)\n\n    return {\n        name: field.name,\n        value,\n        errors,\n        firstError,\n        isValid,\n        onChange: field.onChange,\n        onBlur: field.onBlur,\n        addError: field.addError,\n        validate: field.validate,\n        reset: field.reset,\n        set: field.onChange,\n        resetErrors: field.resetErrors,\n        hasError: () => {\n            return firstError !== null\n        },\n        errorText: (map) => {\n            if (!firstError) {\n                return \"\"\n            }\n            if (!map) {\n                return firstError.errorText || \"\"\n            }\n            if (map[firstError.rule]) {\n                return map[firstError.rule]\n            }\n            return firstError.errorText || \"\"\n        }\n    }\n\n}\n\ntype Result<Fields extends AnyFieldsConfigs> = {\n  fields: ConnectedFields<Fields>\n  values: FormValues<Fields>\n  hasError: (fieldName?: keyof Fields) => boolean\n  eachValid: boolean\n  isValid: boolean\n  errors: (fieldName: keyof Fields) => (\n    // eslint-disable-next-line max-len\n    Fields[typeof fieldName] extends FieldConfig<infer U> ? ValidationError<U>[] : never\n  )\n  error: (fieldName: keyof Fields) => (\n    // eslint-disable-next-line max-len\n    Fields[typeof fieldName] extends FieldConfig<infer U> ? ValidationError<U> : never\n  ) | null\n  errorText: (fieldName: keyof Fields, map?: ErrorTextMap) => string\n  submit: Event<void>\n  reset: Event<void>\n  setForm: Event<Partial<FormValues<Fields>>>\n  set: Event<Partial<FormValues<Fields>>>\n  formValidated: Event<FormValues<Fields>>\n}\n\nexport function useForm<Fields extends AnyFieldsConfigs>(\n    form: Form<Fields>\n) {\n    const connectedFields = {} as AnyConnectedFields\n\n    for (const fieldName in form.fields) {\n        if (!form.fields.hasOwnProperty(fieldName)) continue \n        const field = form.fields[fieldName]\n\n        connectedFields[fieldName] = useField(field)\n    }\n\n    const values = useStore(form.$values)\n    const eachValid = useStore(form.$eachValid)\n\n\n    const hasError = (fieldName?: string): boolean => {\n        if (!fieldName) {\n            return !eachValid\n        }\n        if (connectedFields[fieldName]) {\n            return Boolean(connectedFields[fieldName].firstError)\n        }\n        return false\n    }\n\n    const error = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].firstError\n        }\n        return null\n    }\n\n    const errors = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].errors\n        }\n        return []\n    }\n\n    const errorText = (fieldName: string, map?: ErrorTextMap) => {\n        const field = connectedFields[fieldName]\n        if (!field) {\n            return \"\"\n        }\n        if (!field.firstError) {\n            return \"\"\n        }\n        if (!map) {\n            return field.firstError.errorText || \"\"\n        }\n        if (map[field.firstError.rule]) {\n            return map[field.firstError.rule]\n        }\n        return field.firstError.errorText || \"\"\n    }\n\n    return {\n        fields: connectedFields as ConnectedFields<Fields>,\n        values,\n        hasError,\n        eachValid,\n        isValid: eachValid,\n        errors,\n        error,\n        reset: form.reset,\n        errorText,\n        submit: form.submit,\n        setForm: form.setForm,\n        set: form.setForm, // set form alias\n        formValidated: form.formValidated,\n    } as Result<Fields>\n}\n","import {\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n    createEvent,\n} from \"effector\"\nimport {\n    FieldConfig,\n    Field,\n    AnyFields,\n    AnyFieldsConfigs,\n    AnyFormValues,\n    FormConfig,\n} from \"./types\"\nimport { eachValid } from \"./validation\"\nimport {\n    createField,\n    bindValidation,\n    bindChangeEvent,\n} from \"./field\"\n\nfunction createFormValuesStore(\n    fields: AnyFields\n): Store<AnyFormValues> {\n    const shape: { [key: string]: Store<any> } = {}\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        shape[fieldName] = fields[fieldName].$value\n    }\n\n    return combine(shape)\n}\n\n\nexport type FormValues<Fields extends AnyFieldsConfigs> = {\n  [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n    ? U\n    : never\n}\n\nexport type Form<Fields extends AnyFieldsConfigs> = {\n  fields: {\n    [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n      ? Field<U>\n      : never\n  }\n  $values: Store<FormValues<Fields>>\n  $eachValid: Store<boolean>\n  $isValid: Store<boolean>\n  submit: Event<void>\n  reset: Event<void>\n  set: Event<Partial<FormValues<Fields>>>\n  setForm: Event<Partial<FormValues<Fields>>>\n  formValidated: Event<FormValues<Fields>>\n}\n\n\nexport function createForm<Fields extends AnyFieldsConfigs>(\n    config: FormConfig<Fields>\n) {\n    const {\n        filter: $filter,\n        domain,\n        fields: fieldsConfigs,\n        validateOn,\n    } = config\n\n    const fields: AnyFields = {}\n\n    // create units\n    for (const fieldName in fieldsConfigs) {\n        if (!fieldsConfigs.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n\n        fields[fieldName] = createField(fieldName, fieldConfig, domain)\n    }\n\n    const $form = createFormValuesStore(fields)\n    const $eachValid = eachValid(fields)\n    const $isFormValid = $filter\n        ? combine($eachValid, $filter, (valid, filter) => valid && filter)\n        : $eachValid\n  \n    const submitForm = domain ? domain.event<void>() : createEvent<void>()\n    const formValidated = domain \n        ? domain.event<AnyFormValues>()\n        : createEvent<AnyFormValues>()\n\n    const setForm = domain\n        ? domain.event<Partial<AnyFormValues>>()\n        : createEvent<Partial<AnyFormValues>>()\n\n    const resetForm = domain\n        ? domain.event<void>()\n        : createEvent<void>()\n\n    const submitWithFormData = sample($form, submitForm)\n\n    // bind units\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n        const field = fields[fieldName]\n\n        bindChangeEvent(field, setForm, resetForm)\n\n        if (!fieldConfig.rules) continue\n\n        bindValidation({\n            $form,\n            rules: fieldConfig.rules,\n            submitEvent: submitForm,\n            field,\n            formValidationEvents: validateOn ? validateOn : [\"submit\"],\n            fieldValidationEvents: fieldConfig.validateOn\n                ? fieldConfig.validateOn \n                : [],\n        })\n    }\n\n    guard({\n        source: submitWithFormData,\n        filter: $isFormValid,\n        target: formValidated,\n    })\n\n    return {\n        fields,\n        $values: $form,\n        $eachValid,\n        $isValid: $eachValid,\n        submit: submitForm,\n        reset: resetForm,\n        setForm,\n        set: setForm,\n        formValidated,\n    } as unknown as Form<Fields>\n}\n"],"names":["createField","fieldName","fieldConfig","domain","initValue","init","$value","store","createStore","$errors","$firstError","map","errors","onChange","event","createEvent","onBlur","addError","validate","resetErrors","reset","name","$isValid","firstError","set","bindValidation","$form","submitEvent","field","rules","formValidationEvents","fieldValidationEvents","validator","value","form","rule","result","push","isValid","errorText","createCombineValidator","eventsNames","validationEvents","includes","sample","source","combine","fieldValue","clock","addErrorWithValue","fn","on","_","newError","bindChangeEvent","setForm","resetForm","curr","updateSet","hasOwnProperty","useField","useStore","hasError","config","filter","$filter","fields","fieldsConfigs","validateOn","shape","createFormValuesStore","$eachValid","firstErrors","every","error","eachValid","$isFormValid","valid","submitForm","formValidated","submitWithFormData","guard","target","$values","submit","connectedFields","values","Boolean"],"mappings":"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"}