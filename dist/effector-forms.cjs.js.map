{"version":3,"file":"effector-forms.cjs.js","sources":["../src/create-form-unit.ts","../src/field.ts","../src/validation.ts","../src/react-hooks.ts","../src/factory.ts"],"sourcesContent":["import { createStore, createEvent, Domain, EventCallable, StoreWritable }\r\n    from \"effector\"\r\n\r\ntype CreateStoreParams<Value> = {\r\n    init: Value\r\n    domain?: Domain\r\n    existing?: StoreWritable<Value>\r\n}\r\n\r\nfunction store<Value>(\r\n    { init, domain, existing }: CreateStoreParams<Value>,\r\n    effectorData?: any\r\n) {\r\n    if (existing) {\r\n        return existing\r\n    }\r\n    return domain\r\n        ? domain.createStore(init, effectorData)\r\n        : createStore(init, effectorData)\r\n}\r\n\r\ntype CreateEventParams<Value> = {\r\n    domain?: Domain\r\n    existing?: EventCallable<Value>\r\n}\r\n\r\nfunction event<Value>({ domain, existing }: CreateEventParams<Value>) {\r\n    if (existing) {\r\n        return existing\r\n    }\r\n    return domain ? domain.createEvent<Value>() : createEvent<Value>()\r\n}\r\n\r\nexport const createFormUnit = {\r\n    store,\r\n    event,\r\n}\r\n","import {\r\n    createStore,\r\n    Domain,\r\n    EventCallable,\r\n    Store,\r\n    combine,\r\n    sample,\r\n    guard,\r\n    merge,\r\n    Event,\r\n} from \"effector\"\r\nimport {\r\n    ValidationError,\r\n    Field,\r\n    FieldData,\r\n    FieldConfig,\r\n    AnyFormValues,\r\n    ValidationEvent,\r\n    AddErrorPayload,\r\n    FieldUnitShape,\r\n} from \"./types\"\r\nimport { createCombineValidator } from \"./validation\"\r\nimport { createFormUnit } from \"./create-form-unit\"\r\n\r\n/**\r\n * @group Factories\r\n */\r\nexport function createField(\r\n    fieldName: string,\r\n    fieldConfig: FieldConfig<any>,\r\n    domain?: Domain,\r\n): Field<any> {\r\n    const initValue = typeof fieldConfig.init === \"function\"\r\n        ? fieldConfig.init()\r\n        : fieldConfig.init\r\n\r\n    const $value = createFormUnit.store({\r\n        domain,\r\n        existing: fieldConfig.units?.$value,\r\n        init: initValue,\r\n    }, {\r\n        sid: `${fieldName}-$value`\r\n    })\r\n\r\n    const $errors = createFormUnit.store<ValidationError[]>({\r\n        domain,\r\n        existing: fieldConfig.units?.$errors,\r\n        init: [],\r\n    }, {\r\n        sid: `${fieldName}-$errors`\r\n    })\r\n\r\n\r\n    const $firstError = $errors.map(\r\n        (errors) => errors[0] ? errors[0] : null\r\n    )\r\n\r\n    const $initValue = createFormUnit.store({\r\n        domain,\r\n        existing: fieldConfig.units?.$initValue,\r\n        init: initValue,\r\n    }, {\r\n        sid: `${fieldName}-$initValue`\r\n    })\r\n\r\n    const $touched = createFormUnit.store({\r\n        domain,\r\n        existing: fieldConfig.units?.$isTouched,\r\n        init: false,\r\n    }, {\r\n        sid: `${fieldName}-$touched`\r\n    })\r\n\r\n    const $isDirty = combine($value, $initValue,\r\n        (value, initValue) => value !== initValue,\r\n    )\r\n\r\n    const onChange = createFormUnit.event({\r\n        domain,\r\n        existing: fieldConfig.units?.onChange,\r\n    })\r\n    const onBlur = createFormUnit.event({\r\n        domain,\r\n        existing: fieldConfig.units?.onBlur,\r\n    })\r\n    const changed = createFormUnit.event({\r\n        domain,\r\n        existing: fieldConfig.units?.changed,\r\n    })\r\n    const addError = createFormUnit.event<{\r\n        rule: string\r\n        errorText?: string\r\n    }>({\r\n        domain,\r\n        existing: fieldConfig.units?.addError,\r\n    })\r\n    const validate = createFormUnit.event({\r\n        domain,\r\n        existing: fieldConfig.units?.validate,\r\n    })\r\n    const resetErrors = createFormUnit.event({\r\n        domain,\r\n        existing: fieldConfig.units?.resetErrors,\r\n    })\r\n    const resetValue = createFormUnit.event({\r\n        domain,\r\n        existing: fieldConfig.units?.resetValue,\r\n    })\r\n    const reset = createFormUnit.event({\r\n        domain,\r\n        existing: fieldConfig.units?.reset,\r\n    })\r\n\r\n    const $isValid = $firstError.map((firstError) => firstError === null)\r\n    const $errorText = $firstError.map(\r\n        (firstError) => firstError?.errorText || \"\"\r\n    )\r\n\r\n    const $field = combine({\r\n        value: $value,\r\n        errors: $errors,\r\n        firstError: $firstError,\r\n        isValid: $isValid,\r\n        isDirty: $isDirty,\r\n        isTouched: $touched,\r\n    })\r\n\r\n    const unitShape: FieldUnitShape<any> = {\r\n        value: $value,\r\n        initValue: $initValue,\r\n        isValid: $isValid,\r\n        isDirty: $isDirty,\r\n        touched: $touched,\r\n        errors: $errors,\r\n        firstError: $firstError,\r\n        errorText: $errorText,\r\n        onChange,\r\n        onBlur,\r\n        addError,\r\n        validate,\r\n        reset,\r\n        resetErrors,\r\n        resetValue,\r\n    }\r\n\r\n    return {\r\n        changed,\r\n        \"name\": fieldName,\r\n        $initValue,\r\n        $value,\r\n        $errors,\r\n        $firstError,\r\n        $errorText,\r\n        $isValid,\r\n        $isDirty,\r\n        \"$isTouched\": $touched,\r\n        $touched,\r\n        \"$field\": $field as Store<FieldData<any>>,\r\n        onChange,\r\n        onBlur,\r\n        addError,\r\n        validate,\r\n        \"set\": onChange,\r\n        reset,\r\n        resetErrors,\r\n        resetValue,\r\n        \"filter\": fieldConfig.filter,\r\n        \"@@unitShape\": () => unitShape,\r\n    }\r\n}\r\n\r\ntype BindValidationParams = {\r\n    form: {\r\n        $values: Store<AnyFormValues>\r\n        submit: EventCallable<void>\r\n        reset: EventCallable<void>\r\n        resetValues: EventCallable<void>\r\n        resetErrors: EventCallable<void>\r\n        addErrors: EventCallable<AddErrorPayload[]>\r\n        validate: EventCallable<void>\r\n        validateOn?: ValidationEvent[]\r\n    }\r\n    field: Field<any>\r\n    fieldConfig: FieldConfig<any>\r\n}\r\n\r\nexport function bindValidation(\r\n    params: BindValidationParams, effectorData?: any\r\n): void {\r\n    const { form, field, fieldConfig } = params\r\n    const rules = fieldConfig.rules || []\r\n    const formValidationEvents = form.validateOn || [\"submit\"]\r\n    const fieldValidationEvents = fieldConfig.validateOn || []\r\n\r\n    const {\r\n        $value,\r\n        $errors,\r\n        onBlur,\r\n        changed,\r\n        addError,\r\n        validate,\r\n        resetErrors,\r\n        resetValue,\r\n        reset,\r\n    } = field\r\n\r\n    const rulesSources = typeof rules === \"function\"\r\n        ? createStore<any[]>([], { sid: `${field.name}-$rulesSources` })\r\n        : combine(\r\n            rules.map(({ source }, i) => {\r\n                const sid = `${field.name}-$rulesSources-${i}`\r\n                return source || createStore(null, { sid })\r\n            })\r\n        )\r\n\r\n    const validator = createCombineValidator(rules)\r\n    const eventsNames = [...formValidationEvents, ...fieldValidationEvents]\r\n    const validationEvents: Event<{\r\n        fieldValue: any\r\n        form: AnyFormValues\r\n        rulesSources: any[]\r\n    }>[] = []\r\n\r\n    if (eventsNames.includes(\"submit\")) {\r\n        const validationTrigger = sample({\r\n            source: combine({\r\n                fieldValue: $value,\r\n                form: form.$values,\r\n                rulesSources,\r\n            }),\r\n            clock: form.submit,\r\n        })\r\n\r\n        validationEvents.push(validationTrigger)\r\n    }\r\n\r\n    if (eventsNames.includes(\"blur\")) {\r\n        validationEvents.push(sample({\r\n            source: combine({\r\n                fieldValue: $value,\r\n                form: form.$values,\r\n                rulesSources,\r\n            }),\r\n            clock: onBlur,\r\n        }))\r\n    }\r\n\r\n    if (eventsNames.includes(\"change\")) {\r\n        validationEvents.push(sample({\r\n            source: combine({\r\n                fieldValue: $value,\r\n                form: form.$values,\r\n                rulesSources,\r\n            }),\r\n            clock: merge(\r\n                [changed, resetValue, form.resetValues]\r\n            ),\r\n        }))\r\n    }\r\n\r\n    validationEvents.push(sample({\r\n        source: combine({\r\n            fieldValue: $value,\r\n            form: form.$values,\r\n            rulesSources,\r\n        }),\r\n        clock: validate,\r\n    }))\r\n\r\n    validationEvents.push(sample({\r\n        source: combine({\r\n            fieldValue: $value,\r\n            form: form.$values,\r\n            rulesSources,\r\n        }),\r\n        clock: form.validate,\r\n    }))\r\n\r\n    const addErrorWithValue = sample({\r\n        source: $value,\r\n        clock: addError,\r\n        fn: (value, { rule, errorText }): ValidationError => ({\r\n            rule,\r\n            value,\r\n            errorText,\r\n        }),\r\n    })\r\n\r\n    const addErrorsWithValue = sample({\r\n        source: $value,\r\n        clock: form.addErrors,\r\n        fn: (value, errors) => ({\r\n            value,\r\n            newErrors: errors,\r\n        })\r\n    })\r\n\r\n    $errors\r\n        .on(\r\n            validationEvents,\r\n            (_, { form, fieldValue, rulesSources }) => validator(\r\n                fieldValue,\r\n                form,\r\n                rulesSources,\r\n            )\r\n        )\r\n        .on(addErrorWithValue, (errors, newError) => [newError, ...errors])\r\n        .on(addErrorsWithValue, (currErrors, { value, newErrors }) => {\r\n            const matchedErrors: ValidationError[] = []\r\n\r\n            for (const newError of newErrors) {\r\n                if (newError.field !== field.name) continue\r\n                matchedErrors.push({\r\n                    value,\r\n                    rule: newError.rule,\r\n                    errorText: newError.errorText,\r\n                })\r\n            }\r\n\r\n            return [...matchedErrors, ...currErrors]\r\n        })\r\n        .reset(resetErrors, form.reset, reset, form.resetErrors)\r\n\r\n    if (!eventsNames.includes(\"change\")) {\r\n        $errors.reset(changed)\r\n    }\r\n}\r\n\r\ntype BindChangeEventParams = {\r\n    field: Field<any>\r\n    form: {\r\n        setForm: EventCallable<Partial<AnyFormValues>>\r\n        setInitialForm: EventCallable<Partial<AnyFormValues>>\r\n        resetForm: EventCallable<void>\r\n        resetTouched: EventCallable<void>\r\n        resetValues: EventCallable<void>\r\n    }\r\n}\r\n\r\nexport function bindChangeEvent({\r\n    field,\r\n    form,\r\n}: BindChangeEventParams): void {\r\n    const {\r\n        $value,\r\n        $initValue,\r\n        $touched,\r\n        onChange,\r\n        changed,\r\n        name,\r\n        reset,\r\n        resetValue,\r\n        filter\r\n    } = field\r\n\r\n    const {\r\n        setForm,\r\n        setInitialForm,\r\n        resetForm,\r\n        resetTouched,\r\n        resetValues\r\n    } = form\r\n\r\n    const resetValueWithInit = sample({\r\n        source: $initValue,\r\n        clock: merge([\r\n            reset,\r\n            resetValue,\r\n            resetValues,\r\n            resetForm\r\n        ]),\r\n    })\r\n\r\n    $touched\r\n        .on(changed, () => true)\r\n        .reset(reset, resetForm, resetTouched)\r\n\r\n    guard({\r\n        source: onChange,\r\n        filter: filter || (() => true),\r\n        target: changed,\r\n    })\r\n\r\n    $initValue\r\n        .on(setInitialForm, (curr, updateSet) => updateSet.hasOwnProperty(name)\r\n            ? updateSet[name]\r\n            : curr\r\n        )\r\n\r\n    $value\r\n        .on(changed, (_, value) => value)\r\n        .on(\r\n            [setForm, setInitialForm],\r\n            (curr, updateSet) => updateSet.hasOwnProperty(name)\r\n                ? updateSet[name]\r\n                : curr\r\n        )\r\n        .on(resetValueWithInit, (_, initValue) => initValue)\r\n}\r\n","import { Store, combine } from \"effector\"\r\nimport {\r\n    ValidationError,\r\n    Rule,\r\n    AnyFields,\r\n    RuleResolver,\r\n} from \"./types\"\r\n\r\nexport function createCombineValidator<Value = any, Form = any>(\r\n    rulesOrResolver: Rule<Value, Form, any>[] | RuleResolver<Value, Form>\r\n) {\r\n    return (\r\n        value: Value,\r\n        form: Form,\r\n        rulesSources?: any[]\r\n    ): ValidationError<Value>[] => {\r\n\r\n        const errors: ValidationError<Value>[] = []\r\n        const rules = typeof rulesOrResolver === \"function\"\r\n            ? rulesOrResolver(value, form)\r\n            : rulesOrResolver\r\n\r\n        for (let i = 0; i < rules.length; i++) {\r\n            const rule = rules[i]\r\n            const source = rulesSources ? rulesSources[i] : null\r\n            const result = rule.validator(value, form, source)\r\n\r\n            if (typeof result === \"boolean\" && !result) {\r\n                errors.push({\r\n                    rule: rule.name,\r\n                    errorText: rule.errorText,\r\n                    value,\r\n                })\r\n            }\r\n\r\n            if (typeof result === \"object\" && !result.isValid) {\r\n                errors.push({\r\n                    rule: rule.name,\r\n                    errorText: result.errorText,\r\n                    value,\r\n                })\r\n            }\r\n        }\r\n\r\n        return errors\r\n    }\r\n}\r\n\r\n\r\nexport function eachValid(fields: AnyFields) {\r\n    const firstErrors: Store<ValidationError | null>[] = []\r\n\r\n    for (const fieldName in fields) {\r\n        if (!fields.hasOwnProperty(fieldName)) continue\r\n        const { $firstError } = fields[fieldName]\r\n        firstErrors.push($firstError)\r\n    }\r\n\r\n    const $firstErrors = combine(firstErrors)\r\n\r\n    return $firstErrors.map((errors) => errors.every(error => error === null))\r\n}\r\n","import { useUnit } from \"effector-react\"\r\nimport {\r\n    Field,\r\n    ValidationError,\r\n    AnyFormValues,\r\n    Form\r\n} from \"./types\"\r\n\r\ntype ErrorTextMap = {\r\n    [key: string]: string\r\n}\r\n\r\ntype AddErrorPayload = { rule: string; errorText?: string }\r\n\r\ntype ConnectedField<Value> = {\r\n    name: string\r\n    value: Value\r\n    errors: ValidationError<Value>[]\r\n    firstError: ValidationError<Value> | null\r\n    hasError: () => boolean\r\n    onChange: (v: Value) => Value\r\n    onBlur: (v: void) => void\r\n    errorText: (map?: ErrorTextMap) => string\r\n    addError: (p: AddErrorPayload) => AddErrorPayload\r\n    validate: (v: void) => void\r\n    isValid: boolean\r\n    isDirty: boolean\r\n    isTouched: boolean\r\n    touched: boolean\r\n    reset: (v: void) => void\r\n    set: (v: Value) => Value\r\n    resetErrors: (v: void) => void\r\n}\r\n\r\ntype ConnectedFields<Values extends AnyFormValues> = {\r\n    [K in keyof Values]: ConnectedField<Values[K]>\r\n}\r\n\r\ntype AnyConnectedFields = {\r\n    [key: string]: ConnectedField<any>\r\n}\r\n\r\n/**\r\n * @group Hooks\r\n */\r\nexport function useField<Value>(field: Field<Value>): ConnectedField<Value> {\r\n    const {\r\n        value,\r\n        errors,\r\n        firstError,\r\n        isValid,\r\n        isDirty,\r\n        isTouched: touched,\r\n    } = useUnit(field.$field)\r\n\r\n    return {\r\n        name: field.name,\r\n        value,\r\n        errors,\r\n        firstError,\r\n        isValid,\r\n        isDirty,\r\n        touched,\r\n        isTouched: touched,\r\n        onChange: useUnit(field.onChange),\r\n        onBlur: useUnit(field.onBlur),\r\n        addError: useUnit(field.addError),\r\n        validate: useUnit(field.validate),\r\n        reset: useUnit(field.reset),\r\n        set: useUnit(field.onChange),\r\n        resetErrors: useUnit(field.resetErrors),\r\n        hasError: () => {\r\n            return firstError !== null\r\n        },\r\n        errorText: (map) => {\r\n            if (!firstError) {\r\n                return \"\"\r\n            }\r\n            if (!map) {\r\n                return firstError.errorText || \"\"\r\n            }\r\n            if (map[firstError.rule]) {\r\n                return map[firstError.rule]\r\n            }\r\n            return firstError.errorText || \"\"\r\n        }\r\n    }\r\n\r\n}\r\n\r\ntype Result<Values extends AnyFormValues> = {\r\n    fields: ConnectedFields<Values>\r\n    values: Values\r\n    hasError: (fieldName?: keyof Values) => boolean\r\n    eachValid: boolean\r\n    isValid: boolean\r\n    isDirty: boolean\r\n    isTouched: boolean\r\n    touched: boolean\r\n    errors: (fieldName: keyof Values) => (\r\n        ValidationError<Values[typeof fieldName]>[]\r\n    )\r\n    error: (fieldName: keyof Values) => (\r\n        ValidationError<Values[typeof fieldName]>\r\n    ) | null\r\n    errorText: (fieldName: keyof Values, map?: ErrorTextMap) => string\r\n    submit: (p: void) => void\r\n    reset: (p: void) => void\r\n    setForm: (p: Partial<Values>) => Partial<Values>\r\n    set: (p: Partial<Values>) => Partial<Values>\r\n    formValidated: (p: Values) => Values\r\n}\r\n\r\n/**\r\n * @group Hooks\r\n */\r\nexport function useForm<Values extends AnyFormValues>(\r\n    form: Form<Values>\r\n): Result<Values> {\r\n    const connectedFields = {} as AnyConnectedFields\r\n    const values = {} as AnyFormValues\r\n\r\n    for (const fieldName in form.fields) {\r\n        if (!form.fields.hasOwnProperty(fieldName)) continue\r\n        const field = form.fields[fieldName]\r\n        const connectedField = useField(field)\r\n        connectedFields[fieldName] = connectedField\r\n        values[fieldName] = connectedField.value\r\n    }\r\n\r\n    const {\r\n        isValid: eachValid,\r\n        isDirty,\r\n        touched,\r\n    } = useUnit(form.$meta)\r\n\r\n\r\n    const hasError = (fieldName?: string): boolean => {\r\n        if (!fieldName) {\r\n            return !eachValid\r\n        }\r\n        if (connectedFields[fieldName]) {\r\n            return Boolean(connectedFields[fieldName].firstError)\r\n        }\r\n        return false\r\n    }\r\n\r\n    const error = (fieldName: string) => {\r\n        if (connectedFields[fieldName]) {\r\n            return connectedFields[fieldName].firstError\r\n        }\r\n        return null\r\n    }\r\n\r\n    const errors = (fieldName: string) => {\r\n        if (connectedFields[fieldName]) {\r\n            return connectedFields[fieldName].errors\r\n        }\r\n        return []\r\n    }\r\n\r\n    const errorText = (fieldName: string, map?: ErrorTextMap) => {\r\n        const field = connectedFields[fieldName]\r\n        if (!field) {\r\n            return \"\"\r\n        }\r\n        if (!field.firstError) {\r\n            return \"\"\r\n        }\r\n        if (!map) {\r\n            return field.firstError.errorText || \"\"\r\n        }\r\n        if (map[field.firstError.rule]) {\r\n            return map[field.firstError.rule]\r\n        }\r\n        return field.firstError.errorText || \"\"\r\n    }\r\n\r\n    return {\r\n        fields: connectedFields as ConnectedFields<Values>,\r\n        values,\r\n        hasError,\r\n        eachValid,\r\n        isValid: eachValid,\r\n        isDirty,\r\n        isTouched: touched,\r\n        touched,\r\n        errors,\r\n        error,\r\n        errorText,\r\n        reset: useUnit(form.reset),\r\n        submit: useUnit(form.submit),\r\n        setForm: useUnit(form.setForm),\r\n        set: useUnit(form.setForm), // set form alias\r\n        formValidated: useUnit(form.formValidated),\r\n    } as Result<Values>\r\n}\r\n","import {\r\n    EventCallable,\r\n    Store,\r\n    combine,\r\n    sample,\r\n    guard,\r\n} from \"effector\"\r\nimport {\r\n    AnyFields,\r\n    AnyFormValues,\r\n    FormConfig,\r\n    Form,\r\n    AddErrorPayload,\r\n    FormUnitShape,\r\n} from \"./types\"\r\nimport { eachValid } from \"./validation\"\r\nimport {\r\n    createField,\r\n    bindValidation,\r\n    bindChangeEvent,\r\n} from \"./field\"\r\nimport { createFormUnit } from \"./create-form-unit\"\r\n\r\nfunction createFormValuesStore(\r\n    fields: AnyFields\r\n): Store<AnyFormValues> {\r\n    const shape: { [key: string]: Store<any> } = {}\r\n\r\n    for (const fieldName in fields) {\r\n        if (!fields.hasOwnProperty(fieldName)) continue\r\n        shape[fieldName] = fields[fieldName].$value\r\n    }\r\n\r\n    return combine(shape)\r\n}\r\n\r\n/**\r\n * This is the main factory in the library that creates\r\n * the forms shape according to the given configuration.\r\n * \r\n * Do not try to pass a type in the Values generic! Form types are inferred automatically from the passed \"fields\" object\r\n * \r\n * @param config - The form configuration object\r\n * @returns The shape of effector units\r\n * @example\r\n * \r\n * ```ts\r\n * const form = createForm({\r\n *      fields: {\r\n *          username: {\r\n *              init: \"\",\r\n *              rules: [\r\n *                  {\r\n *                      name: \"required\",\r\n *                      validator: (value: string) => Boolean(value)\r\n *                  }\r\n *              ]\r\n *          },\r\n *          bio: {\r\n *              init: \"\",\r\n *              rules: []\r\n *          }\r\n *      },\r\n *      validateOn: [\"change\"],\r\n * })\r\n * ```\r\n * @group Factories\r\n */\r\nexport function createForm<Values extends AnyFormValues>(\r\n    config: FormConfig<Values>\r\n) {\r\n    const {\r\n        filter: $filter,\r\n        domain,\r\n        fields: fieldsConfigs,\r\n        validateOn,\r\n        units,\r\n    } = config\r\n\r\n    const fields: AnyFields = {}\r\n\r\n    const dirtyFlagsArr: Store<boolean>[] = []\r\n    const touchedFlagsArr: Store<boolean>[] = []\r\n\r\n    // create units\r\n    for (const fieldName in fieldsConfigs) {\r\n        if (!fieldsConfigs.hasOwnProperty(fieldName)) continue\r\n\r\n        const fieldConfig = fieldsConfigs[fieldName]\r\n        const field = createField(fieldName, fieldConfig, domain)\r\n\r\n        fields[fieldName] = field\r\n        dirtyFlagsArr.push(field.$isDirty)\r\n        touchedFlagsArr.push(field.$touched)\r\n    }\r\n\r\n    const $form = createFormValuesStore(fields)\r\n    const $eachValid = eachValid(fields)\r\n    const $isFormValid = $filter\r\n        ? combine($eachValid, $filter, (valid, filter) => valid && filter)\r\n        : $eachValid\r\n    const $isDirty = combine(dirtyFlagsArr).map(\r\n        (dirtyFlags) => dirtyFlags.some(Boolean)\r\n    )\r\n    const $touched = combine(touchedFlagsArr).map(\r\n        (touchedFlags) => touchedFlags.some(Boolean)\r\n    )\r\n\r\n    const $meta = combine({\r\n        isValid: $eachValid,\r\n        isDirty: $isDirty,\r\n        touched: $touched,\r\n    })\r\n\r\n    const validate = createFormUnit.event<void>({\r\n        domain,\r\n        existing: units?.validate,\r\n    })\r\n\r\n    const submitForm = createFormUnit.event<void>({\r\n        domain,\r\n        existing: units?.submit,\r\n    })\r\n\r\n    const formValidated = createFormUnit.event({\r\n        domain,\r\n        existing: units?.formValidated,\r\n    })\r\n\r\n    const setInitialForm = createFormUnit.event<Partial<AnyFormValues>>({\r\n        domain,\r\n        existing: units?.setInitialForm as EventCallable<Partial<AnyFormValues>>\r\n    })\r\n\r\n    const setForm = createFormUnit.event<Partial<AnyFormValues>>({\r\n        domain,\r\n        existing: units?.setForm as EventCallable<Partial<AnyFormValues>>,\r\n    })\r\n\r\n    const addErrors = createFormUnit.event<AddErrorPayload[]>({\r\n        domain,\r\n        existing: units?.addErrors,\r\n    })\r\n\r\n    const resetForm = createFormUnit.event({\r\n        domain,\r\n        existing: units?.reset,\r\n    })\r\n\r\n    const resetValues = createFormUnit.event({\r\n        domain,\r\n        existing: units?.resetValues,\r\n    })\r\n\r\n    const resetErrors = createFormUnit.event({\r\n        domain,\r\n        existing: units?.resetErrors,\r\n    })\r\n\r\n    const resetTouched = createFormUnit.event({\r\n        domain,\r\n        existing: units?.resetTouched,\r\n    })\r\n\r\n    const submitWithFormData = sample({\r\n        source: $form,\r\n        clock: submitForm,\r\n    })\r\n    const validateWithFormData = sample({\r\n        source: $form,\r\n        clock: validate\r\n    })\r\n\r\n    // bind units\r\n    for (const fieldName in fields) {\r\n        if (!fields.hasOwnProperty(fieldName)) continue\r\n\r\n        const fieldConfig = fieldsConfigs[fieldName]\r\n        const field = fields[fieldName]\r\n\r\n        bindChangeEvent({\r\n            form: {\r\n                setForm,\r\n                setInitialForm,\r\n                resetForm,\r\n                resetTouched,\r\n                resetValues\r\n            },\r\n            field,\r\n        })\r\n        bindValidation({\r\n            form: {\r\n                $values: $form,\r\n                submit: submitForm,\r\n                reset: resetForm,\r\n                addErrors,\r\n                resetValues,\r\n                resetErrors,\r\n                validate,\r\n                validateOn,\r\n            },\r\n            fieldConfig,\r\n            field,\r\n        }, { sid: fieldName })\r\n    }\r\n\r\n    guard({\r\n        source: submitWithFormData as unknown as EventCallable<Values>,\r\n        filter: $isFormValid,\r\n        // TODO: fix\r\n        target: formValidated,\r\n    })\r\n\r\n    guard({\r\n        source: validateWithFormData as unknown as EventCallable<Values>,\r\n        filter: $isFormValid,\r\n        target: formValidated,\r\n    })\r\n\r\n    const unitShape: FormUnitShape<any> = {\r\n        isValid: $eachValid,\r\n        isDirty: $isDirty,\r\n        touched: $touched,\r\n        submit: submitForm,\r\n        reset: resetForm,\r\n        addErrors: addErrors,\r\n        validate,\r\n        setForm,\r\n        setInitialForm,\r\n        resetTouched,\r\n        resetValues,\r\n        resetErrors,\r\n        formValidated,\r\n    }\r\n\r\n    return {\r\n        fields,\r\n        \"$values\": $form,\r\n        $eachValid,\r\n        \"$isValid\": $eachValid,\r\n        \"$isDirty\": $isDirty,\r\n        \"$touched\": $touched,\r\n        $meta,\r\n        \"submit\": submitForm,\r\n        validate,\r\n        resetTouched,\r\n        addErrors,\r\n        \"reset\": resetForm,\r\n        resetValues,\r\n        resetErrors,\r\n        setForm,\r\n        setInitialForm,\r\n        \"set\": setForm,\r\n        formValidated,\r\n        \"@@unitShape\": () => unitShape,\r\n    } as unknown as Form<Values>\r\n}\r\n"],"names":["createFormUnit","store","init","domain","existing","effectorData","createStore","and","sid","event","createEvent","createField","fieldName","fieldConfig","_fieldConfig$units","_fieldConfig$units2","_fieldConfig$units3","_fieldConfig$units4","_fieldConfig$units5","_fieldConfig$units6","_fieldConfig$units7","_fieldConfig$units8","_fieldConfig$units9","_fieldConfig$units10","_fieldConfig$units11","_fieldConfig$units12","initValue","$value","units","name","$errors","$firstError","map","errors","$initValue","$touched","$isTouched","$isDirty","combine","value","or","onChange","onBlur","changed","addError","validate","resetErrors","resetValue","reset","$isValid","firstError","$errorText","errorText","$field","isValid","isDirty","isTouched","unitShape","touched","set","filter","@@unitShape","bindValidation","params","form","field","rules","formValidationEvents","validateOn","fieldValidationEvents","rulesSources","source","i","validator","rulesOrResolver","length","rule","result","push","eventsNames","validationEvents","includes","validationTrigger","sample","fieldValue","$values","clock","submit","merge","resetValues","addErrorWithValue","fn","addErrorsWithValue","addErrors","newErrors","on","_","newError","currErrors","matchedErrors","bindChangeEvent","setForm","setInitialForm","resetForm","resetTouched","resetValueWithInit","guard","target","curr","updateSet","hasOwnProperty","useField","useUnit","hasError","config","$filter","fields","fieldsConfigs","dirtyFlagsArr","touchedFlagsArr","$form","shape","createFormValuesStore","$eachValid","firstErrors","every","error","eachValid","$isFormValid","valid","dirtyFlags","some","Boolean","touchedFlags","$meta","submitForm","formValidated","submitWithFormData","validateWithFormData","connectedFields","values","connectedField"],"mappings":"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"}