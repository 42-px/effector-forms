{"version":3,"file":"effector-form.iife.js","sources":["../src/field.ts","../src/validation.ts","../src/factory.ts"],"sourcesContent":["import {\n    Domain,\n    Event,\n    Store,\n    createStore,\n    createEvent,\n    combine, \n    sample,\n} from \"effector\"\nimport {\n    ValidationError,\n    Field,\n    FieldConfig,\n    AnyFormValues,\n    ValidationEvent,\n    Rule,\n} from \"./types\"\nimport { createCombineValidator } from \"./validation\"\n\nexport function createField(\n    fieldName: string,\n    fieldConfig: FieldConfig<any>,\n    domain?: Domain,\n): Field<any> {\n    const initValue = typeof fieldConfig.init === \"function\"\n        ? fieldConfig.init()\n        : fieldConfig.init\n\n    const $value = domain ? domain.store(initValue) : createStore(initValue)\n\n    const $errors = domain\n        ? domain.store<ValidationError[]>([])\n        : createStore<ValidationError[]>([])\n\n    const $firstError = $errors.map(\n        (errors) => errors[0] ? errors[0] : null\n    )\n\n    const onChange = domain ? domain.event() : createEvent()\n    const onBlur = domain ? domain.event() : createEvent()\n\n    return {\n        name: fieldName,\n        $value,\n        $errors,\n        $firstError,\n        onChange,\n        onBlur,\n    }\n}\n\ntype BindValidationParams = {\n  $form: Store<AnyFormValues>\n  submitEvent: Event<void>\n  field: Field<any>\n  rules: Rule<any, any>[]\n  formValidationEvents: ValidationEvent[]\n  fieldValidationEvents: ValidationEvent[]\n}\n\nexport function bindValidation({\n    $form,\n    submitEvent,\n    field,\n    rules,\n    formValidationEvents,\n    fieldValidationEvents\n}: BindValidationParams): void {\n    const { $value, $errors, onBlur, onChange } = field\n    const validator = createCombineValidator(rules)\n    const eventsNames = [...formValidationEvents, ...fieldValidationEvents]\n    const validationEvents: Event<{\n        fieldValue: any\n        form: AnyFormValues\n    }>[] = []\n\n    if (eventsNames.includes(\"submit\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n            }),\n            clock: submitEvent,\n        }))\n    }\n\n    if (eventsNames.includes(\"blur\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n            }),\n            clock: onBlur,\n        }))\n    }\n\n    if (eventsNames.includes(\"change\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n            }),\n            clock: onChange,\n        }))\n    }\n\n    $errors\n        .on(\n            validationEvents,\n            (_, { form, fieldValue }) => validator(fieldValue, form)\n        )\n\n    if (!eventsNames.includes(\"change\")) {\n        $errors.reset(onChange)\n    }\n}\n\nexport function bindChangeEvent(\n    { $value, onChange, name }: Field<any>,\n    setForm: Event<Partial<AnyFormValues>>,\n): void {\n\n    $value\n        .on(onChange, (_, value) => value)\n        .on(\n            setForm,\n            (curr, updateSet) => updateSet.hasOwnProperty(name) \n                ? updateSet[name] \n                : curr\n        )\n}\n","import { Event, Store, combine, sample } from \"effector\"\nimport {\n    ValidationError,\n    Rule,\n    AnyFormValues,\n    Field,\n    AnyFields,\n    ValidationEvent,\n} from \"./types\"\n\nexport function createCombineValidator<Value = any, Form = any>(\n    rules: Rule<Value, Form>[]\n) {\n    return (value: Value, form?: Form): ValidationError<Value>[] => {\n\n        const errors: ValidationError<Value>[] = []\n\n        for (const rule of rules) {\n            const result = rule.validator(value, form)\n\n            if (typeof result === \"boolean\" && !result) {\n                errors.push({\n                    rule: rule.name,\n                    value,\n                })\n            }\n\n            if (typeof result === \"object\" && !result.isValid) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: result.errorText,\n                    value,\n                })\n            }\n        }\n\n        return errors\n    }\n}\n\n\nexport function eachValid(fields: AnyFields) {\n    const firstErrors: Store<ValidationError | null>[] = []\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        const { $firstError } = fields[fieldName]\n        firstErrors.push($firstError)\n    }\n  \n    const $firstErrors = combine(firstErrors)\n  \n    return $firstErrors.map((errors) => errors.every(error => error === null))\n}\n","import {\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n    forward,\n    createEffect,\n    createDomain,\n    createEvent,\n    createStore,\n} from \"effector\"\nimport {\n    FieldConfig,\n    Field,\n    AnyFields,\n    AnyFieldsConfigs,\n    AnyFormValues,\n    FormConfig,\n} from \"./types\"\nimport { eachValid } from \"./validation\"\nimport {\n    createField,\n    bindValidation,\n    bindChangeEvent,\n} from \"./field\"\n\nfunction createFormValuesStore(\n    fields: AnyFields\n): Store<AnyFormValues> {\n    const shape: { [key: string]: Store<any> } = {}\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        shape[fieldName] = fields[fieldName].$value\n    }\n\n    return combine(shape)\n}\n\n\ntype FormValues<Fields extends AnyFieldsConfigs> = {\n  [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n    ? U\n    : never\n}\n\ntype Form<Fields extends AnyFieldsConfigs> = {\n  fields: {\n    [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n      ? Field<U>\n      : never\n  }\n  $values: Store<FormValues<Fields>>\n  $eachValid: Store<boolean>\n  submit: Event<void>\n  setForm: Event<Partial<FormValues<Fields>>>\n  formValidated: Event<FormValues<Fields>>\n}\n\n\nexport function createForm<Fields extends AnyFieldsConfigs>(\n    config: FormConfig<Fields>\n) {\n    const {\n        filter: $filter,\n        domain,\n        fields: fieldsConfigs,\n        validateOn,\n    } = config\n\n    const fields: AnyFields = {}\n\n    // create units\n    for (const fieldName in fieldsConfigs) {\n        if (!fieldsConfigs.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n\n        fields[fieldName] = createField(fieldName, fieldConfig, domain)\n    }\n\n    const $form = createFormValuesStore(fields)\n    const $eachValid = eachValid(fields)\n    const $isFormValid = $filter\n        ? combine($eachValid, $filter, (valid, filter) => valid && filter)\n        : $eachValid\n  \n    const submitForm = domain ? domain.event<void>() : createEvent<void>()\n    const formValidated = domain \n        ? domain.event<AnyFormValues>()\n        : createEvent<AnyFormValues>()\n\n    const setForm = domain\n        ? domain.event<Partial<AnyFormValues>>()\n        : createEvent<Partial<AnyFormValues>>()\n\n    const submitWithFormData = sample($form, submitForm)\n\n    // bind units\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n        const field = fields[fieldName]\n\n        bindChangeEvent(field, setForm)\n\n        if (!fieldConfig.rules) continue\n\n        bindValidation({\n            $form,\n            rules: fieldConfig.rules,\n            submitEvent: submitForm,\n            field,\n            formValidationEvents: validateOn ? validateOn : [\"submit\"],\n            fieldValidationEvents: fieldConfig.validateOn\n                ? fieldConfig.validateOn \n                : [],\n        })\n    }\n\n    guard({\n        source: submitWithFormData,\n        filter: $isFormValid,\n        target: formValidated,\n    })\n\n    return {\n        fields,\n        $values: $form,\n        $eachValid,\n        submit: submitForm,\n        setForm,\n        formValidated,\n    } as unknown as Form<Fields>\n}\n\n\ntype User = {\n  username: string\n  password: string\n}\n\nconst required = () => ({\n    name: \"required\",\n    validator: (val: string) => Boolean(val)\n})\n\nconst createUserFx = createEffect<User, void, Error>()\nconst $serverError = createStore<Error | null>(null)\n\n$serverError.on(createUserFx.failData, (_, error) => error)\n\nconst form = createForm({\n    domain: createDomain(\"my-form\"),\n    validateOn: [\"submit\"],\n    filter: combine(\n        $serverError,\n        createUserFx.pending,\n        (serverError, pending) => !serverError && !pending,\n    ),\n    fields: {\n        username: {\n            init: \"\",\n            rules: [required()],\n        },\n        password: {\n            init: \"\",\n            rules: [required()]\n        }\n    },\n})\n\nforward({\n    from: form.formValidated,\n    to: createUserFx,\n})\n"],"names":["createField","fieldName","fieldConfig","domain","initValue","init","$value","store","createStore","$errors","$firstError","map","errors","name","onChange","event","createEvent","onBlur","bindValidation","$form","submitEvent","field","rules","formValidationEvents","fieldValidationEvents","validator","value","form","rule","result","push","isValid","errorText","createCombineValidator","eventsNames","validationEvents","includes","sample","source","combine","fieldValue","clock","on","_","reset","bindChangeEvent","setForm","curr","updateSet","hasOwnProperty","createForm","config","filter","$filter","fields","fieldsConfigs","validateOn","shape","createFormValuesStore","$eachValid","firstErrors","every","error","eachValid","$isFormValid","valid","submitForm","formValidated","submitWithFormData","guard","target","$values","submit","required","val","Boolean","createUserFx","createEffect","$serverError","failData","createDomain","pending","serverError","username","password","from","to"],"mappings":"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"}