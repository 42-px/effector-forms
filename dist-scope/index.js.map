{"version":3,"file":"index.js","sources":["../src/create-form-unit.ts","../src/field.ts","../src/validation.ts","../src/factory.ts","../src/scope.ts","../src/react-hooks.ts"],"sourcesContent":["import { createStore, createEvent, Domain, Store, Event } from \"effector\"\n\ntype CreateStoreParams<Value> = {\n    init: Value\n    domain?: Domain\n    existing?: Store<Value>\n}\n\nfunction store<Value>(\n    { init, domain, existing }: CreateStoreParams<Value>,\n    effectorData?: any\n) {\n    if (existing) {\n        return existing\n    }\n    return domain\n        ? domain.store(init, effectorData)\n        : createStore(init, effectorData)\n}\n\ntype CreateEventParams<Value> = {\n    domain?: Domain\n    existing?: Event<Value>\n}\n\nfunction event<Value>({ domain, existing }: CreateEventParams<Value>) {\n    if (existing) {\n        return existing\n    }\n    return domain ? domain.event<Value>() : createEvent<Value>()\n}\n\nexport const createFormUnit = {\n    store,\n    event,\n}\n","import {\n    createStore,\n    Domain,\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n    merge,\n} from \"effector\"\nimport {\n    ValidationError,\n    Field,\n    FieldData,\n    FieldConfig,\n    AnyFormValues,\n    ValidationEvent,\n    AddErrorPayload,\n} from \"./types\"\nimport { createCombineValidator } from \"./validation\"\nimport { createFormUnit } from \"./create-form-unit\"\n\nexport function createField(\n    fieldName: string,\n    fieldConfig: FieldConfig<any>,\n    domain?: Domain,\n    effectorData?: any,\n): Field<any> {\n    const initValue = typeof fieldConfig.init === \"function\"\n        ? fieldConfig.init()\n        : fieldConfig.init\n\n    const $value = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$value,\n        init: initValue,\n    }, {\n        sid: `${fieldName}-$value`\n    })\n\n    const $errors = createFormUnit.store<ValidationError[]>({\n        domain,\n        existing: fieldConfig.units?.$errors,\n        init: [],\n    }, {\n        sid: `${fieldName}-$errors`\n    })\n\n\n    const $firstError = $errors.map(\n        (errors) => errors[0] ? errors[0] : null\n    )\n\n    const $initValue = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$initValue,\n        init: initValue,\n    }, {\n        sid: `${fieldName}-$initValue`\n    })\n\n    const $touched = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$isTouched,\n        init: false,\n    }, {\n        sid: `${fieldName}-$touched`\n    })\n\n    const $isDirty = combine($value, $initValue,\n        (value, initValue) => value !== initValue,\n    )\n\n    const onChange = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onChange,\n    })\n    const onBlur = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onBlur,\n    })\n    const changed = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.changed,\n    })\n    const addError = createFormUnit.event<{\n        rule: string\n        errorText?: string\n    }>({\n        domain,\n        existing: fieldConfig.units?.addError,\n    })\n    const validate = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.validate,\n    })\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetErrors,\n    })\n    const resetValue = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetValue,\n    })\n    const reset = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.reset,\n    })\n\n    const $isValid = $firstError.map((firstError) => firstError === null)\n\n    const $field = combine({\n        value: $value,\n        errors: $errors,\n        firstError: $firstError,\n        isValid: $isValid,\n        isDirty: $isDirty,\n        isTouched: $touched,\n    })\n\n    return {\n        changed,\n        name: fieldName,\n        $initValue,\n        $value,\n        $errors,\n        $firstError,\n        $isValid,\n        $isDirty,\n        $isTouched: $touched,\n        $touched,\n        $field: $field as Store<FieldData<any>>,\n        onChange,\n        onBlur,\n        addError,\n        validate,\n        set: onChange,\n        reset,\n        resetErrors,\n        resetValue,\n        filter: fieldConfig.filter,\n    }\n}\n\ntype BindValidationParams = {\n    form: {\n        $values: Store<AnyFormValues>\n        submit: Event<void>\n        reset: Event<void>\n        resetValues: Event<void>\n        resetErrors: Event<void>\n        addErrors: Event<AddErrorPayload[]>\n        validate: Event<void>\n        validateOn?: ValidationEvent[]\n    }\n    field: Field<any>\n    fieldConfig: FieldConfig<any>\n}\n\nexport function bindValidation(\n    params: BindValidationParams, effectorData?: any\n): void {\n    const { form, field, fieldConfig } = params\n    const rules = fieldConfig.rules || []\n    const formValidationEvents = form.validateOn || [\"submit\"]\n    const fieldValidationEvents = fieldConfig.validateOn || []\n\n    const {\n        $value,\n        $errors,\n        onBlur,\n        changed,\n        addError,\n        validate,\n        resetErrors,\n        resetValue,\n        reset,\n    } = field\n\n    const rulesSources = typeof rules === \"function\"\n        ? createStore<any[]>([], { sid: `${field.name}-$rulesSources` })\n        : combine(\n            rules.map(({ source }, i) => {\n                const sid = `${field.name}-$rulesSources-${i}`\n                return source || createStore(null, { sid })\n            })\n        )\n\n    const validator = createCombineValidator(rules)\n    const eventsNames = [...formValidationEvents, ...fieldValidationEvents]\n    const validationEvents: Event<{\n        fieldValue: any\n        form: AnyFormValues\n        rulesSources: any[]\n    }>[] = []\n\n    if (eventsNames.includes(\"submit\")) {\n        const validationTrigger = sample({\n            source: combine({\n                fieldValue: $value,\n                form: form.$values,\n                rulesSources,\n            }),\n            clock: form.submit,\n        })\n\n        validationEvents.push(validationTrigger)\n    }\n\n    if (eventsNames.includes(\"blur\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: form.$values,\n                rulesSources,\n            }),\n            clock: onBlur,\n        }))\n    }\n\n    if (eventsNames.includes(\"change\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: form.$values,\n                rulesSources,\n            }),\n            clock: merge(\n                [changed, resetValue, form.resetValues]\n            ),\n        }))\n    }\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: form.$values,\n            rulesSources,\n        }),\n        clock: validate,\n    }))\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: form.$values,\n            rulesSources,\n        }),\n        clock: form.validate,\n    }))\n\n    const addErrorWithValue = sample({\n        source: $value,\n        clock: addError,\n        fn: (value, { rule, errorText }): ValidationError => ({\n            rule,\n            value,\n            errorText,\n        }),\n    })\n\n    const addErrorsWithValue = sample({\n        source: $value,\n        clock: form.addErrors,\n        fn: (value, errors) => ({\n            value,\n            newErrors: errors,\n        })\n    })\n\n    $errors\n        .on(\n            validationEvents,\n            (_, { form, fieldValue, rulesSources }) => validator(\n                fieldValue,\n                form,\n                rulesSources,\n            )\n        )\n        .on(addErrorWithValue, (errors, newError) => [newError, ...errors])\n        .on(addErrorsWithValue, (currErrors, { value, newErrors }) => {\n            const matchedErrors: ValidationError[] = []\n\n            for (const newError of newErrors) {\n                if (newError.field !== field.name) continue\n                matchedErrors.push({\n                    value,\n                    rule: newError.rule,\n                    errorText: newError.errorText,\n                })\n            }\n\n            return [...matchedErrors, ...currErrors]\n        })\n        .reset(resetErrors, form.reset, reset, form.resetErrors)\n\n    if (!eventsNames.includes(\"change\")) {\n        $errors.reset(changed)\n    }\n}\n\ntype BindChangeEventParams = {\n    field: Field<any>\n    form: {\n        setForm: Event<Partial<AnyFormValues>>\n        setInitialForm: Event<Partial<AnyFormValues>>\n        resetForm: Event<void>\n        resetTouched: Event<void>\n        resetValues: Event<void>\n    }\n}\n\nexport function bindChangeEvent({\n    field,\n    form,\n}: BindChangeEventParams): void {\n    const {\n        $value,\n        $initValue,\n        $touched,\n        onChange,\n        changed,\n        name,\n        reset,\n        resetValue,\n        filter\n    } = field\n\n    const {\n        setForm,\n        setInitialForm,\n        resetForm,\n        resetTouched,\n        resetValues\n    } = form\n\n    $touched\n        .on(changed, () => true)\n        .reset(reset, resetForm, resetTouched)\n\n    guard({\n        source: onChange,\n        filter: filter || (() => true),\n        target: changed,\n    })\n\n    $initValue\n        .on(setInitialForm, (curr, updateSet) => updateSet.hasOwnProperty(name)\n            ? updateSet[name]\n            : curr\n        )\n\n    $value\n        .on(changed, (_, value) => value)\n        .on(\n            [setForm, setInitialForm],\n            (curr, updateSet) => updateSet.hasOwnProperty(name)\n                ? updateSet[name]\n                : curr\n        )\n        .reset(reset, resetValue, resetValues, resetForm)\n}\n","import { Store, combine } from \"effector\"\nimport {\n    ValidationError,\n    Rule,\n    AnyFields,\n    RuleResolver,\n} from \"./types\"\n\nexport function createCombineValidator<Value = any, Form = any>(\n    rulesOrResolver: Rule<Value, Form, any>[] | RuleResolver<Value, Form>\n) {\n    return (\n        value: Value,\n        form: Form,\n        rulesSources?: any[]\n    ): ValidationError<Value>[] => {\n\n        const errors: ValidationError<Value>[] = []\n        const rules = typeof rulesOrResolver === \"function\"\n            ? rulesOrResolver(value, form)\n            : rulesOrResolver\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i]\n            const source = rulesSources ? rulesSources[i] : null\n            const result = rule.validator(value, form, source)\n\n            if (typeof result === \"boolean\" && !result) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: rule.errorText,\n                    value,\n                })\n            }\n\n            if (typeof result === \"object\" && !result.isValid) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: result.errorText,\n                    value,\n                })\n            }\n        }\n\n        return errors\n    }\n}\n\n\nexport function eachValid(fields: AnyFields) {\n    const firstErrors: Store<ValidationError | null>[] = []\n\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        const { $firstError } = fields[fieldName]\n        firstErrors.push($firstError)\n    }\n\n    const $firstErrors = combine(firstErrors)\n\n    return $firstErrors.map((errors) => errors.every(error => error === null))\n}\n","import {\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n} from \"effector\"\nimport {\n    AnyFields,\n    AnyFormValues,\n    FormConfig,\n    Form,\n    AddErrorPayload,\n} from \"./types\"\nimport { eachValid } from \"./validation\"\nimport {\n    createField,\n    bindValidation,\n    bindChangeEvent,\n} from \"./field\"\nimport { createFormUnit } from \"./create-form-unit\"\n\nfunction createFormValuesStore(\n    fields: AnyFields\n): Store<AnyFormValues> {\n    const shape: { [key: string]: Store<any> } = {}\n\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        shape[fieldName] = fields[fieldName].$value\n    }\n\n    return combine(shape)\n}\n\nexport function createForm<Values extends AnyFormValues>(\n    config: FormConfig<Values>\n) {\n    const {\n        filter: $filter,\n        domain,\n        fields: fieldsConfigs,\n        validateOn,\n        units,\n    } = config\n\n    const fields: AnyFields = {}\n\n    const dirtyFlagsArr: Store<boolean>[] = []\n    const touchedFlagsArr: Store<boolean>[] = []\n\n    // create units\n    for (const fieldName in fieldsConfigs) {\n        if (!fieldsConfigs.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n\n        const field = createField(fieldName, fieldConfig, domain, {\n            sid: fieldName\n        })\n\n        fields[fieldName] = field\n        dirtyFlagsArr.push(field.$isDirty)\n        touchedFlagsArr.push(field.$touched)\n    }\n\n    const $form = createFormValuesStore(fields)\n    const $eachValid = eachValid(fields)\n    const $isFormValid = $filter\n        ? combine($eachValid, $filter, (valid, filter) => valid && filter)\n        : $eachValid\n    const $isDirty = combine(dirtyFlagsArr).map(\n        (dirtyFlags) => dirtyFlags.some(Boolean)\n    )\n    const $touched = combine(touchedFlagsArr).map(\n        (touchedFlags) => touchedFlags.some(Boolean)\n    )\n\n    const $meta = combine({\n        isValid: $eachValid,\n        isDirty: $isDirty,\n        touched: $touched,\n    })\n\n    const validate = createFormUnit.event<void>({\n        domain,\n        existing: units?.validate,\n    })\n\n    const submitForm = createFormUnit.event<void>({\n        domain,\n        existing: units?.submit,\n    })\n\n    const formValidated = createFormUnit.event({\n        domain,\n        existing: units?.formValidated,\n    })\n\n    const setInitialForm = createFormUnit.event<Partial<AnyFormValues>>({\n        domain,\n        existing: units?.setInitialForm as Event<Partial<AnyFormValues>>,\n    })\n\n    const setForm = createFormUnit.event<Partial<AnyFormValues>>({\n        domain,\n        existing: units?.setForm as Event<Partial<AnyFormValues>>,\n    })\n\n    const addErrors = createFormUnit.event<AddErrorPayload[]>({\n        domain,\n        existing: units?.addErrors,\n    })\n\n    const resetForm = createFormUnit.event({\n        domain,\n        existing: units?.reset,\n    })\n\n    const resetValues = createFormUnit.event({\n        domain,\n        existing: units?.resetValues,\n    })\n\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: units?.resetErrors,\n    })\n\n    const resetTouched = createFormUnit.event({\n        domain,\n        existing: units?.resetTouched,\n    })\n\n    const submitWithFormData = sample({\n        source: $form,\n        clock: submitForm,\n    })\n    const validateWithFormData = sample({\n        source: $form,\n        clock: validate\n    })\n\n    // bind units\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n        const field = fields[fieldName]\n\n        bindChangeEvent({\n            form: {\n                setForm,\n                setInitialForm,\n                resetForm,\n                resetTouched,\n                resetValues\n            },\n            field,\n        })\n        bindValidation({\n            form: {\n                $values: $form,\n                submit: submitForm,\n                reset: resetForm,\n                addErrors,\n                resetValues,\n                resetErrors,\n                validate,\n                validateOn,\n            },\n            fieldConfig,\n            field,\n        }, { sid: fieldName })\n    }\n\n    guard({\n        source: submitWithFormData as unknown as Event<Values>,\n        filter: $isFormValid,\n        // TODO: fix\n        target: formValidated,\n    })\n\n    guard({\n        source: validateWithFormData as unknown as Event<Values>,\n        filter: $isFormValid,\n        target: formValidated,\n    })\n\n    return {\n        fields,\n        $values: $form,\n        $eachValid,\n        $isValid: $eachValid,\n        $isDirty: $isDirty,\n        $touched: $touched,\n        $meta,\n        submit: submitForm,\n        validate,\n        resetTouched,\n        addErrors,\n        reset: resetForm,\n        resetValues,\n        resetErrors,\n        setForm,\n        setInitialForm,\n        set: setForm,\n        formValidated,\n    } as unknown as Form<Values>\n}\n","import { Event } from \"effector\"\nimport { useEvent } from \"effector-react\"\n\nexport function isScope() {\n    return process.env.IS_SCOPE_BUILD === \"true\"\n}\n\nexport function wrapEvent<P>(event: Event<P>) {\n    return isScope() ? useEvent(event) : event\n}\n\n\n","import { useStore } from \"effector-react\"\nimport {\n    Field,\n    ValidationError,\n    AnyFormValues,\n    Form\n} from \"./types\"\nimport { wrapEvent } from \"./scope\"\n\ntype ErrorTextMap = {\n  [key: string]: string\n}\n\ntype AddErrorPayload = { rule: string; errorText?: string }\n\ntype ConnectedField<Value> = {\n  name: string\n  value: Value\n  errors: ValidationError<Value>[]\n  firstError: ValidationError<Value> | null\n  hasError: () => boolean\n  onChange: (v: Value) => Value\n  onBlur: (v: void) => void\n  errorText: (map?: ErrorTextMap) => string\n  addError: (p: AddErrorPayload) => AddErrorPayload\n  validate: (v: void) => void\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  reset: (v: void) => void\n  set: (v: Value) => Value\n  resetErrors: (v: void) => void\n}\n\ntype ConnectedFields<Values extends AnyFormValues> = {\n  [K in keyof Values]: ConnectedField<Values[K]>\n}\n\ntype AnyConnectedFields = {\n  [key: string]: ConnectedField<any>\n}\n\nexport function useField<Value>(field: Field<Value>): ConnectedField<Value> {\n    const {\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        isTouched: touched,\n    } = useStore(field.$field)\n\n    return {\n        name: field.name,\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        touched,\n        isTouched: touched,\n        onChange: wrapEvent(field.onChange),\n        onBlur: wrapEvent(field.onBlur),\n        addError: wrapEvent(field.addError),\n        validate: wrapEvent(field.validate),\n        reset: wrapEvent(field.reset),\n        set: wrapEvent(field.onChange),\n        resetErrors: wrapEvent(field.resetErrors),\n        hasError: () => {\n            return firstError !== null\n        },\n        errorText: (map) => {\n            if (!firstError) {\n                return \"\"\n            }\n            if (!map) {\n                return firstError.errorText || \"\"\n            }\n            if (map[firstError.rule]) {\n                return map[firstError.rule]\n            }\n            return firstError.errorText || \"\"\n        }\n    }\n\n}\n\ntype Result<Values extends AnyFormValues> = {\n  fields: ConnectedFields<Values>\n  values: Values\n  hasError: (fieldName?: keyof Values) => boolean\n  eachValid: boolean\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  errors: (fieldName: keyof Values) => (\n    ValidationError<Values[typeof fieldName]>[]\n  )\n  error: (fieldName: keyof Values) => (\n    ValidationError<Values[typeof fieldName]>\n  ) | null\n  errorText: (fieldName: keyof Values, map?: ErrorTextMap) => string\n  submit: (p: void) => void\n  reset: (p: void) => void\n  setForm: (p: Partial<Values>) => Partial<Values>\n  set: (p: Partial<Values>) => Partial<Values>\n  formValidated: (p: Values) => Values\n}\n\nexport function useForm<Values extends AnyFormValues>(\n    form: Form<Values>\n): Result<Values> {\n    const connectedFields = {} as AnyConnectedFields\n    const values = {} as AnyFormValues\n\n    for (const fieldName in form.fields) {\n        if (!form.fields.hasOwnProperty(fieldName)) continue\n        const field = form.fields[fieldName]\n        const connectedField = useField(field)\n        connectedFields[fieldName] = connectedField\n        values[fieldName] = connectedField.value\n    }\n\n    const {\n        isValid: eachValid,\n        isDirty,\n        touched,\n    } = useStore(form.$meta)\n\n\n    const hasError = (fieldName?: string): boolean => {\n        if (!fieldName) {\n            return !eachValid\n        }\n        if (connectedFields[fieldName]) {\n            return Boolean(connectedFields[fieldName].firstError)\n        }\n        return false\n    }\n\n    const error = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].firstError\n        }\n        return null\n    }\n\n    const errors = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].errors\n        }\n        return []\n    }\n\n    const errorText = (fieldName: string, map?: ErrorTextMap) => {\n        const field = connectedFields[fieldName]\n        if (!field) {\n            return \"\"\n        }\n        if (!field.firstError) {\n            return \"\"\n        }\n        if (!map) {\n            return field.firstError.errorText || \"\"\n        }\n        if (map[field.firstError.rule]) {\n            return map[field.firstError.rule]\n        }\n        return field.firstError.errorText || \"\"\n    }\n\n    return {\n        fields: connectedFields as ConnectedFields<Values>,\n        values,\n        hasError,\n        eachValid,\n        isValid: eachValid,\n        isDirty,\n        isTouched: touched,\n        touched,\n        errors,\n        error,\n        errorText,\n        reset: wrapEvent(form.reset),\n        submit: wrapEvent(form.submit),\n        setForm: wrapEvent(form.setForm),\n        set: wrapEvent(form.setForm), // set form alias\n        formValidated: wrapEvent(form.formValidated),\n    } as Result<Values>\n}\n"],"names":["createFormUnit","store","init","domain","existing","effectorData","and","sid","createStore","event","createEvent","createField","fieldName","fieldConfig","_fieldConfig$units","_fieldConfig$units2","_fieldConfig$units3","_fieldConfig$units4","_fieldConfig$units5","_fieldConfig$units6","_fieldConfig$units7","_fieldConfig$units8","_fieldConfig$units9","_fieldConfig$units10","_fieldConfig$units11","_fieldConfig$units12","initValue","$value","units","name","$errors","$firstError","map","errors","$initValue","$touched","$isTouched","$isDirty","combine","value","or","onChange","onBlur","changed","addError","validate","resetErrors","resetValue","reset","$isValid","firstError","$field","isValid","isDirty","isTouched","set","filter","bindValidation","params","form","field","rules","formValidationEvents","validateOn","fieldValidationEvents","rulesSources","source","i","validator","rulesOrResolver","length","rule","result","push","errorText","eventsNames","validationEvents","includes","validationTrigger","sample","fieldValue","$values","clock","submit","merge","resetValues","addErrorWithValue","fn","addErrorsWithValue","addErrors","newErrors","on","_","newError","currErrors","matchedErrors","bindChangeEvent","setForm","setInitialForm","resetForm","resetTouched","guard","target","curr","updateSet","hasOwnProperty","createForm","config","$filter","fields","fieldsConfigs","dirtyFlagsArr","touchedFlagsArr","$form","shape","createFormValuesStore","$eachValid","firstErrors","every","error","eachValid","$isFormValid","valid","dirtyFlags","some","Boolean","touchedFlags","$meta","touched","submitForm","formValidated","submitWithFormData","validateWithFormData","wrapEvent","useEvent","useField","useStore","hasError","useForm","connectedFields","values","connectedField"],"mappings":"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"}